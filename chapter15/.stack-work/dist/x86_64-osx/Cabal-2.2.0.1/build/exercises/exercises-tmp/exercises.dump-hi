
==================== FINAL INTERFACE ====================
2018-09-04 07:13:04.791886 UTC

interface main:Main 8043
  interface hash: b56993e63b6bfb2b2416c729c2c30999
  ABI hash: ac04dcedc0d703bc4ec2394ec74b9166
  export-list hash: 1ecae6be2ced624a738cee991e51dfac
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 1d513c99c87e91d88a611f1c4d76ff0e
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.main
module dependencies:
package dependencies: QuickCheck-2.11.3 array-0.5.2.0
                      base-4.11.1.0* containers-0.5.11.0 deepseq-1.4.3.0
                      ghc-boot-th-8.4.3 ghc-prim-0.5.2.0 integer-gmp-1.0.2.0
                      pretty-1.1.3.6 primitive-0.6.3.0 random-1.1
                      template-haskell-2.13.0.0 tf-random-0.5 time-1.8.0.2
                      transformers-0.5.5.0
orphans: transformers-0.5.5.0:Control.Monad.Trans.Error
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal
                         ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
import  -/  QuickCheck-2.11.3:Test.QuickCheck 8597fb70e0afba5fb9d4ded03a4b1b62
import  -/  QuickCheck-2.11.3:Test.QuickCheck.Arbitrary 4df33de46388caa5cd1ba81ee16f6b92
import  -/  QuickCheck-2.11.3:Test.QuickCheck.Gen c4ba69576c6fa40fcf812b985e6beea7
import  -/  QuickCheck-2.11.3:Test.QuickCheck.Test 4bcdfba8853ed701d2281003a6c74081
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
f81c90c9fc05e6c9348caba94b8766c2
  $fArbitraryBoolConj ::
    Test.QuickCheck.Arbitrary.Arbitrary Main.BoolConj
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoolConj
                  Main.$fArbitraryBoolConj1
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.BoolConj>_R))
                  Main.$fArbitraryBoolConj_$cshrink -}
f81c90c9fc05e6c9348caba94b8766c2
  $fArbitraryBoolConj1 ::
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Main.BoolConj
  {- Arity: 2, Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,A>,
     Unfolding: InlineRule (2, True, False)
                (\ (w2 :: Test.QuickCheck.Random.QCGen) (w3 :: GHC.Types.Int) ->
                 case w2
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww1
                        ww2
                        ww3
                        ww4 of ww7 { (#,#) ww8 ww9 ->
                 (Test.QuickCheck.Arbitrary.$w$carbitrary4
                    ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])))
                   `cast`
                 (Sym (Main.N:BoolConj[0])) } }) -}
f81c90c9fc05e6c9348caba94b8766c2
  $fArbitraryBoolConj_$cshrink :: Main.BoolConj -> [Main.BoolConj]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Main.BoolConj) -> GHC.Types.[] @ Main.BoolConj) -}
d4080385790f1b1c227a648ea8e737f2
  $fArbitraryBoolDisj ::
    Test.QuickCheck.Arbitrary.Arbitrary Main.BoolDisj
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoolDisj
                  Main.$fArbitraryBoolDisj1
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.BoolDisj>_R))
                  Main.$fArbitraryBoolDisj_$cshrink -}
d4080385790f1b1c227a648ea8e737f2
  $fArbitraryBoolDisj1 ::
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Main.BoolDisj
  {- Arity: 2, Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,A>,
     Unfolding: InlineRule (2, True, False)
                (\ (w2 :: Test.QuickCheck.Random.QCGen) (w3 :: GHC.Types.Int) ->
                 case w2
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww1
                        ww2
                        ww3
                        ww4 of ww7 { (#,#) ww8 ww9 ->
                 (Test.QuickCheck.Arbitrary.$w$carbitrary4
                    ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0])))
                   `cast`
                 (Sym (Main.N:BoolDisj[0])) } }) -}
d4080385790f1b1c227a648ea8e737f2
  $fArbitraryBoolDisj_$cshrink :: Main.BoolDisj -> [Main.BoolDisj]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Main.BoolDisj) -> GHC.Types.[] @ Main.BoolDisj) -}
71ca1b5b4596959890806ef0546c868c
  $fArbitraryFour ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b,
     Test.QuickCheck.Arbitrary.Arbitrary c,
     Test.QuickCheck.Arbitrary.Arbitrary d) =>
    Test.QuickCheck.Arbitrary.Arbitrary (Main.Four a b c d)
  DFunId
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      @ c
                      @ d
                      (v :: Test.QuickCheck.Arbitrary.Arbitrary a)
                      (v1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                      (v2 :: Test.QuickCheck.Arbitrary.Arbitrary c)
                      (v3 :: Test.QuickCheck.Arbitrary.Arbitrary d).
                  @ (Main.Four a b c d)
                  (Main.$fArbitraryFour1 @ a @ b @ c @ d v v1 v2 v3)
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.Four a b c d>_R))
                  (\ (ds :: Main.Four a b c d) ->
                   GHC.Types.[] @ (Main.Four a b c d)) -}
71ca1b5b4596959890806ef0546c868c
  $fArbitraryFour1 ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b,
     Test.QuickCheck.Arbitrary.Arbitrary c,
     Test.QuickCheck.Arbitrary.Arbitrary d) =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Main.Four a b c d
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   @ b
                   @ c
                   @ d
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (w2 :: Test.QuickCheck.Arbitrary.Arbitrary c)
                   (w3 :: Test.QuickCheck.Arbitrary.Arbitrary d)
                   (w4 :: Test.QuickCheck.Random.QCGen)
                   (w5 :: GHC.Types.Int) ->
                 case w4
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case Main.$w$carbitrary
                        @ a
                        @ b
                        @ c
                        @ d
                        w
                        w1
                        w2
                        w3
                        ww1
                        ww2
                        ww3
                        ww4
                        w5 of ww7 { (#,,,#) ww8 ww9 ww10 ww11 ->
                 Main.Four @ a @ b @ c @ d ww8 ww9 ww10 ww11 } }) -}
b27b2bcfa6a2502f098d5043d45d1104
  $fArbitraryFour_$s$carbitrary ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Main.Four
         Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char]
  {- Arity: 2, Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Test.QuickCheck.Random.QCGen) (w1 :: GHC.Types.Int) ->
                 case w `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case Main.$w$s$carbitrary
                        ww1
                        ww2
                        ww3
                        ww4
                        w1 of ww7 { (#,,,#) ww8 ww9 ww10 ww11 ->
                 Main.Four
                   @ Main.Trivial
                   @ [GHC.Types.Char]
                   @ Main.Trivial
                   @ [GHC.Types.Char]
                   ww8
                   ww9
                   ww10
                   ww11 } }) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $fArbitraryIdentity ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Arbitrary.Arbitrary (Main.Identity a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: Test.QuickCheck.Arbitrary.Arbitrary a).
                  @ (Main.Identity a)
                  (Main.$fArbitraryIdentity1 @ a v)
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.Identity a>_R))
                  (\ (ds :: Main.Identity a) -> GHC.Types.[] @ (Main.Identity a)) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $fArbitraryIdentity1 ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Main.Identity a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$carbitrary1 @ a w ww1 ww2 ww3 ww4 w2 }) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fArbitraryOr ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Arbitrary.Arbitrary (Main.Or a b)
  DFunId
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      (v :: Test.QuickCheck.Arbitrary.Arbitrary a)
                      (v1 :: Test.QuickCheck.Arbitrary.Arbitrary b).
                  @ (Main.Or a b)
                  (Main.$fArbitraryOr1 @ a @ b v v1)
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.Or a b>_R))
                  (\ (ds :: Main.Or a b) -> GHC.Types.[] @ (Main.Or a b)) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fArbitraryOr1 ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Main.Or a b
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (w2 :: Test.QuickCheck.Random.QCGen)
                   (w3 :: GHC.Types.Int) ->
                 case w2
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$carbitrary2 @ a @ b w w1 ww1 ww2 ww3 ww4 w3 }) -}
91c3e64623a62db03fe559c3bb4d3e83
  $fArbitraryOr2 :: [Main.Or [GHC.Types.Char] Main.Trivial]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Main.Or [GHC.Types.Char] Main.Trivial)
                   Main.$fArbitraryOr3
                   (GHC.Types.[] @ (Main.Or [GHC.Types.Char] Main.Trivial))) -}
00f26c02ddb40027d5a579c537605441
  $fArbitraryOr3 :: Main.Or [GHC.Types.Char] Main.Trivial
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Main.Snd
                   @ [GHC.Types.Char]
                   @ Main.Trivial
                   Main.Trivial) -}
877b3c4701c137d677fc136e06303752
  $fArbitraryOr_$s$carbitrary ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> Main.Or [GHC.Types.Char] Main.Trivial
  {- Arity: 2, Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U(U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Test.QuickCheck.Random.QCGen) (w1 :: GHC.Types.Int) ->
                 case w `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$s$carbitrary1 ww1 ww2 ww3 ww4 w1 }) -}
8be194816a28d8986f52eec848797f66
  $fArbitraryThree ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b,
     Test.QuickCheck.Arbitrary.Arbitrary c) =>
    Test.QuickCheck.Arbitrary.Arbitrary (Main.Three a b c)
  DFunId
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      @ c
                      (v :: Test.QuickCheck.Arbitrary.Arbitrary a)
                      (v1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                      (v2 :: Test.QuickCheck.Arbitrary.Arbitrary c).
                  @ (Main.Three a b c)
                  (Main.$fArbitraryThree1 @ a @ b @ c v v1 v2)
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.Three a b c>_R))
                  (\ (ds :: Main.Three a b c) ->
                   GHC.Types.[] @ (Main.Three a b c)) -}
8be194816a28d8986f52eec848797f66
  $fArbitraryThree1 ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b,
     Test.QuickCheck.Arbitrary.Arbitrary c) =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Main.Three a b c
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (w2 :: Test.QuickCheck.Arbitrary.Arbitrary c)
                   (w3 :: Test.QuickCheck.Random.QCGen)
                   (w4 :: GHC.Types.Int) ->
                 case w3
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case Main.$w$carbitrary3
                        @ a
                        @ b
                        @ c
                        w
                        w1
                        w2
                        ww1
                        ww2
                        ww3
                        ww4
                        w4 of ww7 { (#,,#) ww8 ww9 ww10 ->
                 Main.Three @ a @ b @ c ww8 ww9 ww10 } }) -}
43ed0d8edea96358eea6f2f8c271cbec
  $fArbitraryThree_$s$carbitrary ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial
  {- Arity: 2, Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Test.QuickCheck.Random.QCGen) (w1 :: GHC.Types.Int) ->
                 case w `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case Main.$w$s$carbitrary2
                        ww1
                        ww2
                        ww3
                        ww4
                        w1 of ww7 { (#,,#) ww8 ww9 ww10 ->
                 Main.Three
                   @ Main.Trivial
                   @ [GHC.Types.Char]
                   @ Main.Trivial
                   ww8
                   ww9
                   ww10 } }) -}
45254d41351bf1a0f3b9fd85ef078bac
  $fArbitraryTrivial ::
    Test.QuickCheck.Arbitrary.Arbitrary Main.Trivial
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Trivial
                  Main.$fArbitraryTrivial1
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.Trivial>_R))
                  Main.$fArbitraryTrivial_$cshrink -}
45254d41351bf1a0f3b9fd85ef078bac
  $fArbitraryTrivial1 ::
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Main.Trivial
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Test.QuickCheck.Random.QCGen) (ds1 :: GHC.Types.Int) ->
                 Main.Trivial) -}
45254d41351bf1a0f3b9fd85ef078bac
  $fArbitraryTrivial_$cshrink :: Main.Trivial -> [Main.Trivial]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Main.Trivial) -> GHC.Types.[] @ Main.Trivial) -}
6915335e4f938e3f9ae253446cb392f1
  $fArbitraryTwo ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Arbitrary.Arbitrary (Main.Two a b)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      (v :: Test.QuickCheck.Arbitrary.Arbitrary a)
                      (v1 :: Test.QuickCheck.Arbitrary.Arbitrary b).
                  @ (Main.Two a b)
                  (Main.$fArbitraryTwo1 @ a @ b v v1)
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.Two a b>_R))
                  (\ (ds :: Main.Two a b) -> GHC.Types.[] @ (Main.Two a b)) -}
6915335e4f938e3f9ae253446cb392f1
  $fArbitraryTwo1 ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Main.Two a b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (w2 :: Test.QuickCheck.Random.QCGen)
                   (w3 :: GHC.Types.Int) ->
                 case w2
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case Main.$w$carbitrary4
                        @ a
                        @ b
                        w
                        w1
                        ww1
                        ww2
                        ww3
                        ww4
                        w3 of ww7 { (#,#) ww8 ww9 ->
                 Main.Two @ a @ b ww8 ww9 } }) -}
4f53a6dc41a048020220f07a17eabee7
  $fArbitraryTwo_$s$carbitrary ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> Main.Two Main.Trivial [GHC.Types.Char]
  {- Arity: 2, Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Test.QuickCheck.Random.QCGen) (w1 :: GHC.Types.Int) ->
                 case w `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case Main.$w$s$carbitrary3
                        ww1
                        ww2
                        ww3
                        ww4
                        w1 of ww7 { (#,#) ww8 ww9 ->
                 Main.Two @ Main.Trivial @ [GHC.Types.Char] ww8 ww9 } }) -}
f81c90c9fc05e6c9348caba94b8766c2
  $fEqBoolConj :: GHC.Classes.Eq Main.BoolConj
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoolConj
                  GHC.Classes.$fEqBool_$c==
                    `cast`
                  (Sym (Main.N:BoolConj[0])
                   ->_R Sym (Main.N:BoolConj[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fEqBool_$c/=
                    `cast`
                  (Sym (Main.N:BoolConj[0])
                   ->_R Sym (Main.N:BoolConj[0])
                   ->_R <GHC.Types.Bool>_R) -}
d4080385790f1b1c227a648ea8e737f2
  $fEqBoolDisj :: GHC.Classes.Eq Main.BoolDisj
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoolDisj
                  GHC.Classes.$fEqBool_$c==
                    `cast`
                  (Sym (Main.N:BoolDisj[0])
                   ->_R Sym (Main.N:BoolDisj[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.$fEqBool_$c/=
                    `cast`
                  (Sym (Main.N:BoolDisj[0])
                   ->_R Sym (Main.N:BoolDisj[0])
                   ->_R <GHC.Types.Bool>_R) -}
71ca1b5b4596959890806ef0546c868c
  $fEqFour ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c,
     GHC.Classes.Eq d) =>
    GHC.Classes.Eq (Main.Four a b c d)
  DFunId
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      @ c
                      @ d
                      (v :: GHC.Classes.Eq a)
                      (v1 :: GHC.Classes.Eq b)
                      (v2 :: GHC.Classes.Eq c)
                      (v3 :: GHC.Classes.Eq d).
                  @ (Main.Four a b c d)
                  (Main.$fEqFour_$c== @ a @ b @ c @ d v v1 v2 v3)
                  (Main.$fEqFour_$c/= @ a @ b @ c @ d v v1 v2 v3) -}
71ca1b5b4596959890806ef0546c868c
  $fEqFour_$c/= ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c,
     GHC.Classes.Eq d) =>
    Main.Four a b c d -> Main.Four a b c d -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U(U,U,U,U)><S,1*U(U,U,U,U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (6, False, False)
                (\ @ a
                   @ b
                   @ c
                   @ d
                   ($dEq :: GHC.Classes.Eq a)
                   ($dEq1 :: GHC.Classes.Eq b)
                   ($dEq2 :: GHC.Classes.Eq c)
                   ($dEq3 :: GHC.Classes.Eq d)
                   (x :: Main.Four a b c d)
                   (y :: Main.Four a b c d) ->
                 case Main.$fEqFour_$c==
                        @ a
                        @ b
                        @ c
                        @ d
                        $dEq
                        $dEq1
                        $dEq2
                        $dEq3
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
71ca1b5b4596959890806ef0546c868c
  $fEqFour_$c== ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c,
     GHC.Classes.Eq d) =>
    Main.Four a b c d -> Main.Four a b c d -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U(U,U,U,U)><S,1*U(U,U,U,U)>,
     Unfolding: (\ @ a
                   @ b
                   @ c
                   @ d
                   ($dEq :: GHC.Classes.Eq a)
                   ($dEq1 :: GHC.Classes.Eq b)
                   ($dEq2 :: GHC.Classes.Eq c)
                   ($dEq3 :: GHC.Classes.Eq d)
                   (ds :: Main.Four a b c d)
                   (ds1 :: Main.Four a b c d) ->
                 case ds of wild { Main.Four a1 a2 a3 a4 ->
                 case ds1 of wild1 { Main.Four b1 b2 b3 b4 ->
                 case GHC.Classes.== @ a $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.== @ b $dEq1 a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case GHC.Classes.== @ c $dEq2 a3 b3 of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.== @ d $dEq3 a4 b4 } } } } }) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $fEqIdentity ::
    GHC.Classes.Eq a => GHC.Classes.Eq (Main.Identity a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(1*U,1*U)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (Main.Identity a)
                  (GHC.Classes.== @ a v)
                    `cast`
                  (Sym (Main.N:Identity[0] <a>_R)
                   ->_R Sym (Main.N:Identity[0] <a>_R)
                   ->_R <GHC.Types.Bool>_R)
                  (GHC.Classes./= @ a v)
                    `cast`
                  (Sym (Main.N:Identity[0] <a>_R)
                   ->_R Sym (Main.N:Identity[0] <a>_R)
                   ->_R <GHC.Types.Bool>_R) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fEqOr ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    GHC.Classes.Eq (Main.Or a b)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      (v :: GHC.Classes.Eq a)
                      (v1 :: GHC.Classes.Eq b).
                  @ (Main.Or a b)
                  (Main.$fEqOr_$c== @ a @ b v v1)
                  (Main.$fEqOr_$c/= @ a @ b v v1) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fEqOr_$c/= ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    Main.Or a b -> Main.Or a b -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (4, False, False)
                (\ @ a
                   @ b
                   ($dEq :: GHC.Classes.Eq a)
                   ($dEq1 :: GHC.Classes.Eq b)
                   (x :: Main.Or a b)
                   (y :: Main.Or a b) ->
                 case x of wild {
                   Main.Fst a1
                   -> case y of wild1 {
                        Main.Fst b1
                        -> case GHC.Classes.== @ a $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False }
                        Main.Snd ipv -> GHC.Types.True }
                   Main.Snd a1
                   -> case y of wild1 {
                        Main.Fst ipv -> GHC.Types.True
                        Main.Snd b1
                        -> case GHC.Classes.== @ b $dEq1 a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fEqOr_$c== ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    Main.Or a b -> Main.Or a b -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   ($dEq :: GHC.Classes.Eq a)
                   ($dEq1 :: GHC.Classes.Eq b)
                   (ds :: Main.Or a b)
                   (ds1 :: Main.Or a b) ->
                 case ds of wild {
                   Main.Fst a1
                   -> case ds1 of wild1 {
                        Main.Fst b1 -> GHC.Classes.== @ a $dEq a1 b1
                        Main.Snd ipv -> GHC.Types.False }
                   Main.Snd a1
                   -> case ds1 of wild1 {
                        Main.Fst ipv -> GHC.Types.False
                        Main.Snd b1 -> GHC.Classes.== @ b $dEq1 a1 b1 } }) -}
8be194816a28d8986f52eec848797f66
  $fEqThree ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) =>
    GHC.Classes.Eq (Main.Three a b c)
  DFunId
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      @ c
                      (v :: GHC.Classes.Eq a)
                      (v1 :: GHC.Classes.Eq b)
                      (v2 :: GHC.Classes.Eq c).
                  @ (Main.Three a b c)
                  (Main.$fEqThree_$c== @ a @ b @ c v v1 v2)
                  (Main.$fEqThree_$c/= @ a @ b @ c v v1 v2) -}
8be194816a28d8986f52eec848797f66
  $fEqThree_$c/= ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) =>
    Main.Three a b c -> Main.Three a b c -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U(U,U,U)><S,1*U(U,U,U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (5, False, False)
                (\ @ a
                   @ b
                   @ c
                   ($dEq :: GHC.Classes.Eq a)
                   ($dEq1 :: GHC.Classes.Eq b)
                   ($dEq2 :: GHC.Classes.Eq c)
                   (x :: Main.Three a b c)
                   (y :: Main.Three a b c) ->
                 case Main.$fEqThree_$c== @ a @ b @ c $dEq $dEq1 $dEq2 x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
8be194816a28d8986f52eec848797f66
  $fEqThree_$c== ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) =>
    Main.Three a b c -> Main.Three a b c -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U(U,U,U)><S,1*U(U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: GHC.Classes.Eq a)
                   (w1 :: GHC.Classes.Eq b)
                   (w2 :: GHC.Classes.Eq c)
                   (w3 :: Main.Three a b c)
                   (w4 :: Main.Three a b c) ->
                 case w3 of ww { Main.Three ww1 ww2 ww3 ->
                 case w4 of ww4 { Main.Three ww5 ww6 ww7 ->
                 Main.$w$c== @ a @ b @ c w w1 w2 ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
45254d41351bf1a0f3b9fd85ef078bac
  $fEqTrivial :: GHC.Classes.Eq Main.Trivial
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Trivial Main.$fEqTrivial_$c== Main.$fEqTrivial_$c/= -}
45254d41351bf1a0f3b9fd85ef078bac
  $fEqTrivial_$c/= :: Main.Trivial -> Main.Trivial -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*H><S,1*H>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Main.Trivial) (y :: Main.Trivial) ->
                 case x of wild { Main.Trivial ->
                 case y of wild1 { Main.Trivial -> GHC.Types.False } }) -}
45254d41351bf1a0f3b9fd85ef078bac
  $fEqTrivial_$c== :: Main.Trivial -> Main.Trivial -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*H><S,1*H>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Main.Trivial) (ds1 :: Main.Trivial) ->
                 case ds of wild { Main.Trivial ->
                 case ds1 of wild1 { Main.Trivial -> GHC.Types.True } }) -}
6915335e4f938e3f9ae253446cb392f1
  $fEqTwo ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    GHC.Classes.Eq (Main.Two a b)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U(C(C1(U)),A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      (v :: GHC.Classes.Eq a)
                      (v1 :: GHC.Classes.Eq b).
                  @ (Main.Two a b)
                  (Main.$fEqTwo_$c== @ a @ b v v1)
                  (Main.$fEqTwo_$c/= @ a @ b v v1) -}
6915335e4f938e3f9ae253446cb392f1
  $fEqTwo_$c/= ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    Main.Two a b -> Main.Two a b -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U(U,U)><S,1*U(U,U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (4, False, False)
                (\ @ a
                   @ b
                   ($dEq :: GHC.Classes.Eq a)
                   ($dEq1 :: GHC.Classes.Eq b)
                   (x :: Main.Two a b)
                   (y :: Main.Two a b) ->
                 case x of wild { Main.Two a1 a2 ->
                 case y of wild1 { Main.Two b1 b2 ->
                 case GHC.Classes.== @ a $dEq a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.== @ b $dEq1 a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
6915335e4f938e3f9ae253446cb392f1
  $fEqTwo_$c== ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    Main.Two a b -> Main.Two a b -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,1*U(U,U)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Classes.Eq a)
                   (w1 :: GHC.Classes.Eq b)
                   (w2 :: Main.Two a b)
                   (w3 :: Main.Two a b) ->
                 case w2 of ww { Main.Two ww1 ww2 ->
                 case w3 of ww3 { Main.Two ww4 ww5 ->
                 Main.$w$c==1 @ a @ b w w1 ww1 ww2 ww4 ww5 } }) -}
f81c90c9fc05e6c9348caba94b8766c2
  $fSemigroupBoolConj :: GHC.Base.Semigroup Main.BoolConj
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoolConj
                  Main.$fSemigroupBoolConj_$c<>
                  Main.$fSemigroupBoolConj_$csconcat
                  Main.$fSemigroupBoolConj_$cstimes -}
f81c90c9fc05e6c9348caba94b8766c2
  $fSemigroupBoolConj_$c<> ::
    Main.BoolConj -> Main.BoolConj -> Main.BoolConj
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Main.BoolConj) (ds1 :: Main.BoolConj) ->
                 case ds `cast` (Main.N:BoolConj[0]) of wild {
                   GHC.Types.False -> ds1
                   GHC.Types.True
                   -> GHC.Types.True `cast` (Sym (Main.N:BoolConj[0])) }) -}
f81c90c9fc05e6c9348caba94b8766c2
  $fSemigroupBoolConj_$csconcat ::
    GHC.Base.NonEmpty Main.BoolConj -> Main.BoolConj
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SS),1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.NonEmpty Main.BoolConj) ->
                 case ds of wild { GHC.Base.:| a1 as ->
                 Main.$fSemigroupBoolConj_go a1 as }) -}
f81c90c9fc05e6c9348caba94b8766c2
  $fSemigroupBoolConj_$cstimes ::
    GHC.Real.Integral b => b -> Main.BoolConj -> Main.BoolConj
  {- Arity: 1, Strictness: <L,U> -}
f81c90c9fc05e6c9348caba94b8766c2
  $fSemigroupBoolConj_go ::
    Main.BoolConj -> [Main.BoolConj] -> Main.BoolConj
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
d4080385790f1b1c227a648ea8e737f2
  $fSemigroupBoolDisj :: GHC.Base.Semigroup Main.BoolDisj
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoolDisj
                  Main.$fSemigroupBoolDisj_$c<>
                  Main.$fSemigroupBoolDisj_$csconcat
                  Main.$fSemigroupBoolDisj_$cstimes -}
d4080385790f1b1c227a648ea8e737f2
  $fSemigroupBoolDisj_$c<> ::
    Main.BoolDisj -> Main.BoolDisj -> Main.BoolDisj
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Main.BoolDisj) (ds1 :: Main.BoolDisj) ->
                 case ds `cast` (Main.N:BoolDisj[0]) of wild {
                   GHC.Types.False
                   -> GHC.Types.False `cast` (Sym (Main.N:BoolDisj[0]))
                   GHC.Types.True -> ds1 }) -}
d4080385790f1b1c227a648ea8e737f2
  $fSemigroupBoolDisj_$csconcat ::
    GHC.Base.NonEmpty Main.BoolDisj -> Main.BoolDisj
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SS),1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.NonEmpty Main.BoolDisj) ->
                 case ds of wild { GHC.Base.:| a1 as ->
                 Main.$fSemigroupBoolDisj_go a1 as }) -}
d4080385790f1b1c227a648ea8e737f2
  $fSemigroupBoolDisj_$cstimes ::
    GHC.Real.Integral b => b -> Main.BoolDisj -> Main.BoolDisj
  {- Arity: 1, Strictness: <L,U> -}
d4080385790f1b1c227a648ea8e737f2
  $fSemigroupBoolDisj_go ::
    Main.BoolDisj -> [Main.BoolDisj] -> Main.BoolDisj
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
bbe5f09bbf3262cb0ffd25ca31cd894e
  $fSemigroupCombine ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
    GHC.Base.Semigroup (Main.Combine a b)
  DFunId
  {- Arity: 2, Strictness: <L,A><L,U(C(C1(U)),A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      (v :: GHC.Base.Semigroup a)
                      (v1 :: GHC.Base.Semigroup b).
                  @ (Main.Combine a b)
                  (\ (ds :: Main.Combine a b) (ds1 :: Main.Combine a b) (eta :: a) ->
                   GHC.Base.$fSemigroup(->)_$c<>
                     @ b
                     @ a
                     v1
                     ds `cast` (Main.N:Combine[0] <a>_N <b>_N)
                     ds1 `cast` (Main.N:Combine[0] <a>_N <b>_N)
                     eta)
                    `cast`
                  (<Main.Combine a b>_R
                   ->_R <Main.Combine a b>_R
                   ->_R Sym (Main.N:Combine[0]) <a>_N <b>_N)
                  (Main.$fSemigroupCombine_$csconcat @ a @ b v v1)
                  (Main.$fSemigroupCombine_$cstimes @ a @ b v v1) -}
bbe5f09bbf3262cb0ffd25ca31cd894e
  $fSemigroupCombine_$csconcat ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
    GHC.Base.NonEmpty (Main.Combine a b) -> Main.Combine a b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Base.Semigroup a)
                   (w1 :: GHC.Base.Semigroup b)
                   (w2 :: GHC.Base.NonEmpty (Main.Combine a b)) ->
                 case w2 of ww { GHC.Base.:| ww1 ww2 ->
                 Main.$w$csconcat @ a @ b w1 ww1 ww2 }) -}
bbe5f09bbf3262cb0ffd25ca31cd894e
  $fSemigroupCombine_$cstimes ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
    forall b1.
    GHC.Real.Integral b1 =>
    b1 -> Main.Combine a b -> Main.Combine a b
  {- Arity: 3, Strictness: <L,A><L,U(C(C1(U)),A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ b
                   (w :: GHC.Base.Semigroup a)
                   (w1 :: GHC.Base.Semigroup b)
                   @ b1
                   (w2 :: GHC.Real.Integral b1) ->
                 Main.$w$cstimes @ a @ b w1 @ b1 w2) -}
71ca1b5b4596959890806ef0546c868c
  $fSemigroupFour ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
     GHC.Base.Semigroup d) =>
    GHC.Base.Semigroup (Main.Four a b c d)
  DFunId
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      @ c
                      @ d
                      (v :: GHC.Base.Semigroup a)
                      (v1 :: GHC.Base.Semigroup b)
                      (v2 :: GHC.Base.Semigroup c)
                      (v3 :: GHC.Base.Semigroup d).
                  @ (Main.Four a b c d)
                  (Main.$fSemigroupFour_$c<> @ a @ b @ c @ d v v1 v2 v3)
                  (Main.$fSemigroupFour_$csconcat @ a @ b @ c @ d v v1 v2 v3)
                  (Main.$fSemigroupFour_$cstimes @ a @ b @ c @ d v v1 v2 v3) -}
71ca1b5b4596959890806ef0546c868c
  $fSemigroupFour_$c<> ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
     GHC.Base.Semigroup d) =>
    Main.Four a b c d -> Main.Four a b c d -> Main.Four a b c d
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U,U)><S,1*U(U,U,U,U)>m,
     Unfolding: (\ @ a
                   @ b
                   @ c
                   @ d
                   ($dSemigroup :: GHC.Base.Semigroup a)
                   ($dSemigroup1 :: GHC.Base.Semigroup b)
                   ($dSemigroup2 :: GHC.Base.Semigroup c)
                   ($dSemigroup3 :: GHC.Base.Semigroup d)
                   (ds :: Main.Four a b c d)
                   (ds1 :: Main.Four a b c d) ->
                 case ds of wild { Main.Four x1 y1 z1 a1 ->
                 case ds1 of wild1 { Main.Four x2 y2 z2 a2 ->
                 Main.Four
                   @ a
                   @ b
                   @ c
                   @ d
                   (GHC.Base.<> @ a $dSemigroup x1 x2)
                   (GHC.Base.<> @ b $dSemigroup1 y1 y2)
                   (GHC.Base.<> @ c $dSemigroup2 z1 z2)
                   (GHC.Base.<> @ d $dSemigroup3 a1 a2) } }) -}
71ca1b5b4596959890806ef0546c868c
  $fSemigroupFour_$csconcat ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
     GHC.Base.Semigroup d) =>
    GHC.Base.NonEmpty (Main.Four a b c d) -> Main.Four a b c d
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U,U),1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   @ c
                   @ d
                   (w :: GHC.Base.Semigroup a)
                   (w1 :: GHC.Base.Semigroup b)
                   (w2 :: GHC.Base.Semigroup c)
                   (w3 :: GHC.Base.Semigroup d)
                   (w4 :: GHC.Base.NonEmpty (Main.Four a b c d)) ->
                 case w4 of ww { GHC.Base.:| ww1 ww2 ->
                 case ww1 of ww3 { Main.Four ww4 ww5 ww6 ww7 ->
                 case Main.$w$csconcat1
                        @ a
                        @ b
                        @ c
                        @ d
                        w
                        w1
                        w2
                        w3
                        ww4
                        ww5
                        ww6
                        ww7
                        ww2 of ww8 { (#,,,#) ww9 ww10 ww11 ww12 ->
                 Main.Four @ a @ b @ c @ d ww9 ww10 ww11 ww12 } } }) -}
71ca1b5b4596959890806ef0546c868c
  $fSemigroupFour_$cstimes ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
     GHC.Base.Semigroup d) =>
    forall b1.
    GHC.Real.Integral b1 =>
    b1 -> Main.Four a b c d -> Main.Four a b c d
  {- Arity: 5,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U> -}
147471c9f57eed22cd4e53cf0fafdf8f
  $fSemigroupIdentity ::
    GHC.Base.Semigroup a => GHC.Base.Semigroup (Main.Identity a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Base.Semigroup a).
                  @ (Main.Identity a)
                  (\ (ds :: Main.Identity a) (ds1 :: Main.Identity a) ->
                   GHC.Base.<>
                     @ a
                     v
                     ds `cast` (Main.N:Identity[0] <a>_R)
                     ds1 `cast` (Main.N:Identity[0] <a>_R))
                    `cast`
                  (<Main.Identity a>_R
                   ->_R <Main.Identity a>_R
                   ->_R Sym (Main.N:Identity[0] <a>_R))
                  (Main.$fSemigroupIdentity_$csconcat @ a v)
                  (Main.$fSemigroupIdentity_$cstimes @ a v) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $fSemigroupIdentity_$csconcat ::
    GHC.Base.Semigroup a =>
    GHC.Base.NonEmpty (Main.Identity a) -> Main.Identity a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><S(LS),1*U(U,1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: GHC.Base.Semigroup a)
                   (w1 :: GHC.Base.NonEmpty (Main.Identity a)) ->
                 case w1 of ww { GHC.Base.:| ww1 ww2 ->
                 Main.$w$csconcat2 @ a w ww1 ww2 }) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $fSemigroupIdentity_$cstimes ::
    GHC.Base.Semigroup a =>
    forall b.
    GHC.Real.Integral b =>
    b -> Main.Identity a -> Main.Identity a
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U> -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fSemigroupOr :: GHC.Base.Semigroup (Main.Or a b)
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ a @ b.
                  @ (Main.Or a b)
                  (Main.$fSemigroupOr_$c<> @ a @ b)
                  (Main.$fSemigroupOr_$csconcat @ a @ b)
                  (Main.$fSemigroupOr_$cstimes @ a @ b) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fSemigroupOr1 :: Main.Or a b -> [Main.Or a b] -> Main.Or a b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fSemigroupOr_$c<> :: Main.Or a b -> Main.Or a b -> Main.Or a b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (ds :: Main.Or a b) (ds1 :: Main.Or a b) ->
                 case ds of wild {
                   Main.Fst x -> ds1
                   Main.Snd x
                   -> case ds1 of wild1 { DEFAULT -> Main.Snd @ a @ b x } }) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fSemigroupOr_$csconcat ::
    GHC.Base.NonEmpty (Main.Or a b) -> Main.Or a b
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SS),1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b (ds :: GHC.Base.NonEmpty (Main.Or a b)) ->
                 case ds of wild { GHC.Base.:| a1 as ->
                 Main.$fSemigroupOr1 @ a @ b a1 as }) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fSemigroupOr_$cstimes ::
    GHC.Real.Integral b2 => b2 -> Main.Or a b1 -> Main.Or a b1
  {- Arity: 1, Strictness: <L,U> -}
8be194816a28d8986f52eec848797f66
  $fSemigroupThree ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
     GHC.Base.Semigroup c) =>
    GHC.Base.Semigroup (Main.Three a b c)
  DFunId
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      @ c
                      (v :: GHC.Base.Semigroup a)
                      (v1 :: GHC.Base.Semigroup b)
                      (v2 :: GHC.Base.Semigroup c).
                  @ (Main.Three a b c)
                  (Main.$fSemigroupThree_$c<> @ a @ b @ c v v1 v2)
                  (Main.$fSemigroupThree_$csconcat @ a @ b @ c v v1 v2)
                  (Main.$fSemigroupThree_$cstimes @ a @ b @ c v v1 v2) -}
8be194816a28d8986f52eec848797f66
  $fSemigroupThree_$c<> ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
     GHC.Base.Semigroup c) =>
    Main.Three a b c -> Main.Three a b c -> Main.Three a b c
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U,U)><S,1*U(U,U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: GHC.Base.Semigroup a)
                   (w1 :: GHC.Base.Semigroup b)
                   (w2 :: GHC.Base.Semigroup c)
                   (w3 :: Main.Three a b c)
                   (w4 :: Main.Three a b c) ->
                 case w3 of ww { Main.Three ww1 ww2 ww3 ->
                 case w4 of ww4 { Main.Three ww5 ww6 ww7 ->
                 Main.Three
                   @ a
                   @ b
                   @ c
                   (GHC.Base.<> @ a w ww1 ww5)
                   (GHC.Base.<> @ b w1 ww2 ww6)
                   (GHC.Base.<> @ c w2 ww3 ww7) } }) -}
8be194816a28d8986f52eec848797f66
  $fSemigroupThree_$csconcat ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
     GHC.Base.Semigroup c) =>
    GHC.Base.NonEmpty (Main.Three a b c) -> Main.Three a b c
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U,U),1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: GHC.Base.Semigroup a)
                   (w1 :: GHC.Base.Semigroup b)
                   (w2 :: GHC.Base.Semigroup c)
                   (w3 :: GHC.Base.NonEmpty (Main.Three a b c)) ->
                 case w3 of ww { GHC.Base.:| ww1 ww2 ->
                 case ww1 of ww3 { Main.Three ww4 ww5 ww6 ->
                 case Main.$w$csconcat3
                        @ a
                        @ b
                        @ c
                        w
                        w1
                        w2
                        ww4
                        ww5
                        ww6
                        ww2 of ww7 { (#,,#) ww8 ww9 ww10 ->
                 Main.Three @ a @ b @ c ww8 ww9 ww10 } } }) -}
8be194816a28d8986f52eec848797f66
  $fSemigroupThree_$cstimes ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
     GHC.Base.Semigroup c) =>
    forall b1.
    GHC.Real.Integral b1 =>
    b1 -> Main.Three a b c -> Main.Three a b c
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U> -}
45254d41351bf1a0f3b9fd85ef078bac
  $fSemigroupTrivial :: GHC.Base.Semigroup Main.Trivial
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Trivial
                  Main.$fSemigroupTrivial_$c<>
                  Main.$fSemigroupTrivial_$csconcat
                  Main.$fSemigroupTrivial_$cstimes -}
45254d41351bf1a0f3b9fd85ef078bac
  $fSemigroupTrivial_$c<> ::
    Main.Trivial -> Main.Trivial -> Main.Trivial
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Main.Trivial) (ds1 :: Main.Trivial) -> Main.Trivial) -}
45254d41351bf1a0f3b9fd85ef078bac
  $fSemigroupTrivial_$csconcat ::
    GHC.Base.NonEmpty Main.Trivial -> Main.Trivial
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(1*U(),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.NonEmpty Main.Trivial) ->
                 case ds of wild { GHC.Base.:| a1 as ->
                 case as of wild1 { [] -> a1 : c cs -> Main.Trivial } }) -}
45254d41351bf1a0f3b9fd85ef078bac
  $fSemigroupTrivial_$cstimes ::
    GHC.Real.Integral b => b -> Main.Trivial -> Main.Trivial
  {- Arity: 1, Strictness: <L,U> -}
6915335e4f938e3f9ae253446cb392f1
  $fSemigroupTwo ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
    GHC.Base.Semigroup (Main.Two a b)
  DFunId
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      (v :: GHC.Base.Semigroup a)
                      (v1 :: GHC.Base.Semigroup b).
                  @ (Main.Two a b)
                  (Main.$fSemigroupTwo_$c<> @ a @ b v v1)
                  (Main.$fSemigroupTwo_$csconcat @ a @ b v v1)
                  (Main.$fSemigroupTwo_$cstimes @ a @ b v v1) -}
6915335e4f938e3f9ae253446cb392f1
  $fSemigroupTwo_$c<> ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
    Main.Two a b -> Main.Two a b -> Main.Two a b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U)><S,1*U(U,U)>m,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dSemigroup :: GHC.Base.Semigroup a)
                   ($dSemigroup1 :: GHC.Base.Semigroup b)
                   (ds :: Main.Two a b)
                   (ds1 :: Main.Two a b) ->
                 case ds of wild { Main.Two x1 y1 ->
                 case ds1 of wild1 { Main.Two x2 y2 ->
                 Main.Two
                   @ a
                   @ b
                   (GHC.Base.<> @ a $dSemigroup x1 x2)
                   (GHC.Base.<> @ b $dSemigroup1 y1 y2) } }) -}
6915335e4f938e3f9ae253446cb392f1
  $fSemigroupTwo_$csconcat ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
    GHC.Base.NonEmpty (Main.Two a b) -> Main.Two a b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><S(SS),1*U(1*U(U,U),1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Base.Semigroup a)
                   (w1 :: GHC.Base.Semigroup b)
                   (w2 :: GHC.Base.NonEmpty (Main.Two a b)) ->
                 case w2 of ww { GHC.Base.:| ww1 ww2 ->
                 case ww1 of ww3 { Main.Two ww4 ww5 ->
                 case Main.$w$csconcat4
                        @ a
                        @ b
                        w
                        w1
                        ww4
                        ww5
                        ww2 of ww6 { (#,#) ww7 ww8 ->
                 Main.Two @ a @ b ww7 ww8 } } }) -}
6915335e4f938e3f9ae253446cb392f1
  $fSemigroupTwo_$cstimes ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
    forall b1.
    GHC.Real.Integral b1 =>
    b1 -> Main.Two a b -> Main.Two a b
  {- Arity: 3,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U> -}
f81c90c9fc05e6c9348caba94b8766c2
  $fShowBoolConj :: GHC.Show.Show Main.BoolConj
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoolConj
                  Main.$fShowBoolConj_$cshowsPrec
                  Main.$fShowBoolConj_$cshow
                  Main.$fShowBoolConj_$cshowList -}
f81c90c9fc05e6c9348caba94b8766c2
  $fShowBoolConj1 :: Main.BoolConj -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U><L,1*U>,
     Unfolding: (\ (ds :: Main.BoolConj) (x :: GHC.Base.String) ->
                 GHC.CString.unpackAppendCString#
                   Main.$fShowBoolConj2
                   (case ds `cast` (Main.N:BoolConj[0]) of wild {
                      GHC.Types.False
                      -> GHC.Base.++ @ GHC.Types.Char GHC.Show.$fShowBool4 x
                      GHC.Types.True
                      -> GHC.Base.++ @ GHC.Types.Char GHC.Show.$fShowBool2 x })) -}
1726b094c6d0924fa7c032e298cf0a2f
  $fShowBoolConj2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BoolConj "#) -}
f81c90c9fc05e6c9348caba94b8766c2
  $fShowBoolConj_$cshow :: Main.BoolConj -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (x :: Main.BoolConj) ->
                 GHC.CString.unpackAppendCString#
                   Main.$fShowBoolConj2
                   (case x `cast` (Main.N:BoolConj[0]) of wild {
                      GHC.Types.False -> GHC.Show.$fShowBool4
                      GHC.Types.True -> GHC.Show.$fShowBool2 })) -}
f81c90c9fc05e6c9348caba94b8766c2
  $fShowBoolConj_$cshowList :: [Main.BoolConj] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.BoolConj]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Main.BoolConj Main.$fShowBoolConj1 ls s) -}
f81c90c9fc05e6c9348caba94b8766c2
  $fShowBoolConj_$cshowsPrec ::
    GHC.Types.Int -> Main.BoolConj -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><L,1*U><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Main.BoolConj)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Main.$w$cshowsPrec ww1 w1 w2 }) -}
d4080385790f1b1c227a648ea8e737f2
  $fShowBoolDisj :: GHC.Show.Show Main.BoolDisj
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.BoolDisj
                  Main.$fShowBoolDisj_$cshowsPrec
                  Main.$fShowBoolDisj_$cshow
                  Main.$fShowBoolDisj_$cshowList -}
d4080385790f1b1c227a648ea8e737f2
  $fShowBoolDisj1 :: Main.BoolDisj -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U><L,1*U>,
     Unfolding: (\ (ds :: Main.BoolDisj) (x :: GHC.Base.String) ->
                 GHC.CString.unpackAppendCString#
                   Main.$fShowBoolDisj2
                   (case ds `cast` (Main.N:BoolDisj[0]) of wild {
                      GHC.Types.False
                      -> GHC.Base.++ @ GHC.Types.Char GHC.Show.$fShowBool4 x
                      GHC.Types.True
                      -> GHC.Base.++ @ GHC.Types.Char GHC.Show.$fShowBool2 x })) -}
b54024af61b5bec9bdf5e685e3077ac1
  $fShowBoolDisj2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BoolDisj "#) -}
d4080385790f1b1c227a648ea8e737f2
  $fShowBoolDisj_$cshow :: Main.BoolDisj -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (x :: Main.BoolDisj) ->
                 GHC.CString.unpackAppendCString#
                   Main.$fShowBoolDisj2
                   (case x `cast` (Main.N:BoolDisj[0]) of wild {
                      GHC.Types.False -> GHC.Show.$fShowBool4
                      GHC.Types.True -> GHC.Show.$fShowBool2 })) -}
d4080385790f1b1c227a648ea8e737f2
  $fShowBoolDisj_$cshowList :: [Main.BoolDisj] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.BoolDisj]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Main.BoolDisj Main.$fShowBoolDisj1 ls s) -}
d4080385790f1b1c227a648ea8e737f2
  $fShowBoolDisj_$cshowsPrec ::
    GHC.Types.Int -> Main.BoolDisj -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><L,1*U><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Main.BoolDisj)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Main.$w$cshowsPrec1 ww1 w1 w2 }) -}
71ca1b5b4596959890806ef0546c868c
  $fShowFour ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c,
     GHC.Show.Show d) =>
    GHC.Show.Show (Main.Four a b c d)
  DFunId
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      @ c
                      @ d
                      (v :: GHC.Show.Show a)
                      (v1 :: GHC.Show.Show b)
                      (v2 :: GHC.Show.Show c)
                      (v3 :: GHC.Show.Show d).
                  @ (Main.Four a b c d)
                  (Main.$fShowFour_$cshowsPrec @ a @ b @ c @ d v v1 v2 v3)
                  (Main.$fShowFour_$cshow @ a @ b @ c @ d v v1 v2 v3)
                  (Main.$fShowFour_$cshowList @ a @ b @ c @ d v v1 v2 v3) -}
6ab0ccc8e082255dc1b65dfe76b362a4
  $fShowFour1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
9e89cde459634d4a2b163a868736b52d
  $fShowFour2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
b80f98fb57a7cfcb1f2e397618862fc7
  $fShowFour3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.$fShowFour4) -}
635d87031fe6ce964017101dc0922360
  $fShowFour4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Trivial"#) -}
2333d9eb25c4d0d8b6eb9ae5f26c844f
  $fShowFour5 :: (GHC.Types.Char -> b -> b) -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ b
                   (c :: GHC.Types.Char -> b -> b)[OneShot]
                   (n :: b)[OneShot] ->
                 GHC.CString.unpackFoldrCString# @ b "Four "# c n) -}
2851b273cd319bd6470e022492f57a59
  $fShowFour6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Four "#) -}
ab01fdde2553eaa8789360a299ee5bef
  $fShowFour7 ::
    Main.Four
      Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(1*H,1*U,1*H,1*U)><L,U>,
     Unfolding: (\ (w :: Main.Four
                           Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char])
                   (w1 :: GHC.Base.String) ->
                 case w of ww { Main.Four ww1 ww2 ww3 ww4 ->
                 Main.$w$s$cshowsPrec 0# ww1 ww2 ww3 ww4 w1 }) -}
365b53c1ce2f3592ef2bd85ebc6d4ef9
  $fShowFour8 :: [GHC.Types.Char]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.$fShow(,)3
                   (GHC.Types.[] @ GHC.Types.Char)) -}
71ca1b5b4596959890806ef0546c868c
  $fShowFour_$cshow ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c,
     GHC.Show.Show d) =>
    Main.Four a b c d -> GHC.Base.String
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,1*U(U,U,U,U)>,
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   @ c
                   @ d
                   ($dShow :: GHC.Show.Show a)
                   ($dShow1 :: GHC.Show.Show b)
                   ($dShow2 :: GHC.Show.Show c)
                   ($dShow3 :: GHC.Show.Show d)
                   (x :: Main.Four a b c d) ->
                 Main.$fShowFour_$cshowsPrec
                   @ a
                   @ b
                   @ c
                   @ d
                   $dShow
                   $dShow1
                   $dShow2
                   $dShow3
                   Main.$fShowFour2
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
71ca1b5b4596959890806ef0546c868c
  $fShowFour_$cshowList ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c,
     GHC.Show.Show d) =>
    [Main.Four a b c d] -> GHC.Show.ShowS
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   @ b
                   @ c
                   @ d
                   ($dShow :: GHC.Show.Show a)
                   ($dShow1 :: GHC.Show.Show b)
                   ($dShow2 :: GHC.Show.Show c)
                   ($dShow3 :: GHC.Show.Show d)
                   (ls :: [Main.Four a b c d])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Four a b c d)
                   (Main.$fShowFour_$cshowsPrec
                      @ a
                      @ b
                      @ c
                      @ d
                      $dShow
                      $dShow1
                      $dShow2
                      $dShow3
                      Main.$fShowFour2)
                   ls
                   s) -}
71ca1b5b4596959890806ef0546c868c
  $fShowFour_$cshowsPrec ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c,
     GHC.Show.Show d) =>
    GHC.Types.Int -> Main.Four a b c d -> GHC.Show.ShowS
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (6, True, False)
                (\ @ a
                   @ b
                   @ c
                   @ d
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (w2 :: GHC.Show.Show c)
                   (w3 :: GHC.Show.Show d)
                   (w4 :: GHC.Types.Int)
                   (w5 :: Main.Four a b c d) ->
                 case w4 of ww { GHC.Types.I# ww1 ->
                 case w5 of ww2 { Main.Four ww3 ww4 ww5 ww6 ->
                 Main.$w$cshowsPrec2
                   @ a
                   @ b
                   @ c
                   @ d
                   w
                   w1
                   w2
                   w3
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6 } }) -}
686d60a33c79ecf67882d5d5b486a91d
  $fShowFour_$s$cshow ::
    Main.Four
      Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char]
    -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*H,1*U,1*H,1*U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Main.Four
                           Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char]) ->
                 case w of ww { Main.Four ww1 ww2 ww3 ww4 ->
                 Main.$w$s$cshow ww1 ww2 ww3 ww4 }) -}
7b544b42902c3572b3001ec5abe56421
  $fShowFour_$s$cshowList ::
    [Main.Four
       Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char]]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.Four
                             Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char]])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Four
                        Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char])
                   Main.$fShowFour7
                   ls
                   s) -}
71ca1b5b4596959890806ef0546c868c
  $fShowFour_$s$cshowsPrec ::
    GHC.Types.Int
    -> Main.Four
         Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char]
    -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S(S),1*U(U)><S,1*U(1*H,1*U,1*H,1*U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Main.Four
                            Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char])
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Main.Four ww3 ww4 ww5 ww6 ->
                 Main.$w$s$cshowsPrec ww1 ww3 ww4 ww5 ww6 w2 } }) -}
71ca1b5b4596959890806ef0546c868c
  $fShowFour_$s$fShowFour ::
    GHC.Show.Show
      (Main.Four
         Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char])
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Main.Four
                       Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char])
                  Main.$fShowFour_$s$cshowsPrec
                  (\ (x :: Main.Four
                             Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char]) ->
                   case x of wild { Main.Four b1 b2 b3 b4 ->
                   let {
                     p :: GHC.Show.ShowS {- Arity: 1 -}
                     = \ (x1 :: GHC.Base.String) ->
                       GHC.Base.augment
                         @ GHC.Types.Char
                         Main.$fShowFour5
                         (case b1 of wild1 { Main.Trivial ->
                          GHC.Base.augment
                            @ GHC.Types.Char
                            (\ @ b
                               (c :: GHC.Types.Char -> b -> b)[OneShot]
                               (n :: b)[OneShot] ->
                             GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowFour3)
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.showSpace1
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.$fShow(,)3
                                  (GHC.Show.showLitString
                                     b2
                                     (GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.$fShow(,)3
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.showSpace1
                                           (case b3 of wild2 { Main.Trivial ->
                                            GHC.Base.augment
                                              @ GHC.Types.Char
                                              (\ @ b
                                                 (c :: GHC.Types.Char -> b -> b)[OneShot]
                                                 (n :: b)[OneShot] ->
                                               GHC.Base.foldr
                                                 @ GHC.Types.Char
                                                 @ b
                                                 c
                                                 n
                                                 Main.$fShowFour3)
                                              (GHC.Types.:
                                                 @ GHC.Types.Char
                                                 GHC.Show.showSpace1
                                                 (GHC.Types.:
                                                    @ GHC.Types.Char
                                                    GHC.Show.$fShow(,)3
                                                    (GHC.Show.showLitString
                                                       b4
                                                       (GHC.Types.:
                                                          @ GHC.Types.Char
                                                          GHC.Show.$fShow(,)3
                                                          x1)))) })))))) })
                   } in
                   case GHC.Classes.geInt Main.$fShowFour2 Main.$fShowFour1 of wild1 {
                     GHC.Types.False -> p (GHC.Types.[] @ GHC.Types.Char)
                     GHC.Types.True
                     -> GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.$fShow(,)4
                          (p (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.$fShow(,)2
                                (GHC.Types.[] @ GHC.Types.Char))) } })
                  (\ (ls :: [Main.Four
                               Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char]])
                     (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (Main.Four
                          Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char])
                     (Main.$fShowFour_$s$cshowsPrec Main.$fShowFour2)
                     ls
                     s) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $fShowIdentity ::
    GHC.Show.Show a => GHC.Show.Show (Main.Identity a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Main.Identity a)
                  (Main.$fShowIdentity_$cshowsPrec @ a v)
                  (Main.$fShowIdentity_$cshow @ a v)
                  (Main.$fShowIdentity_$cshowList @ a v) -}
d6684afb455d0d4922bbc56b1e4ac9b1
  $fShowIdentity1 :: (GHC.Types.Char -> b -> b) -> b -> b
  {- Arity: 2, Strictness: <L,C(C1(U))><L,U>,
     Unfolding: (\ @ b
                   (c :: GHC.Types.Char -> b -> b)[OneShot]
                   (n :: b)[OneShot] ->
                 letrec {
                   go :: [GHC.Types.Char] -> b {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Types.Char]) ->
                     case ds of wild { [] -> n : y ys -> c y (go ys) }
                 } in
                 go Main.$fShowIdentity2) -}
339ebe6ba767f04f901ad0e8210ca6c0
  $fShowIdentity2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.$fShowIdentity3) -}
3312419380fcdb5b20ba8af7de271c21
  $fShowIdentity3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Identity "#) -}
eb41630b01658ef20af539e513831444
  $fShowIdentity4 :: Main.Identity [GHC.Types.Char] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Main.Identity [GHC.Types.Char]) (x :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowIdentity2)
                   (GHC.Types.:
                      @ GHC.Types.Char
                      GHC.Show.$fShow(,)3
                      (GHC.Show.showLitString
                         ds `cast` (Main.N:Identity[0] <[GHC.Types.Char]>_R)
                         (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 x)))) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $fShowIdentity_$cshow ::
    GHC.Show.Show a => Main.Identity a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x :: Main.Identity a) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowIdentity2)
                   (GHC.Show.showsPrec
                      @ a
                      $dShow
                      Main.$fShowFour1
                      x `cast` (Main.N:Identity[0] <a>_R)
                      (GHC.Types.[] @ GHC.Types.Char))) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $fShowIdentity_$cshowList ::
    GHC.Show.Show a => [Main.Identity a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Main.Identity a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Identity a)
                   (Main.$fShowIdentity_$cshowsPrec @ a $dShow Main.$fShowFour2)
                   ls
                   s) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $fShowIdentity_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Main.Identity a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Main.Identity a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Main.$w$cshowsPrec3 @ a w ww1 w2 }) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $fShowIdentity_$s$cshow ::
    Main.Identity [GHC.Types.Char] -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Main.Identity [GHC.Types.Char]) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowIdentity2)
                   (GHC.Types.:
                      @ GHC.Types.Char
                      GHC.Show.$fShow(,)3
                      (GHC.Show.showLitString
                         x `cast` (Main.N:Identity[0] <[GHC.Types.Char]>_R)
                         (GHC.Types.:
                            @ GHC.Types.Char
                            GHC.Show.$fShow(,)3
                            (GHC.Types.[] @ GHC.Types.Char))))) -}
83cb36de6f8b280c6b99de2841e0ac46
  $fShowIdentity_$s$cshowList ::
    [Main.Identity [GHC.Types.Char]] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.Identity [GHC.Types.Char]])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Identity [GHC.Types.Char])
                   Main.$fShowIdentity4
                   ls
                   s) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $fShowIdentity_$s$cshowsPrec ::
    GHC.Types.Int -> Main.Identity [GHC.Types.Char] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><L,1*U><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Main.Identity [GHC.Types.Char])
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Main.$w$s$cshowsPrec1 ww1 w1 w2 }) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $fShowIdentity_$s$fShowIdentity ::
    GHC.Show.Show (Main.Identity [GHC.Types.Char])
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Main.Identity [GHC.Types.Char])
                  Main.$fShowIdentity_$s$cshowsPrec
                  Main.$fShowIdentity_$s$cshow
                  (\ (ls :: [Main.Identity [GHC.Types.Char]])
                     (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (Main.Identity [GHC.Types.Char])
                     (\ (ds :: Main.Identity [GHC.Types.Char]) ->
                      case GHC.Classes.geInt Main.$fShowFour2 Main.$fShowFour1 of wild {
                        GHC.Types.False
                        -> \ (x :: GHC.Base.String)[OneShot] ->
                           GHC.Base.augment
                             @ GHC.Types.Char
                             Main.$fShowIdentity1
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.$fShow(,)3
                                (GHC.Show.showLitString
                                   ds `cast` (Main.N:Identity[0] <[GHC.Types.Char]>_R)
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 x)))
                        GHC.Types.True
                        -> \ (x :: GHC.Base.String)[OneShot] ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.augment
                                @ GHC.Types.Char
                                Main.$fShowIdentity1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.$fShow(,)3
                                   (GHC.Show.showLitString
                                      ds `cast` (Main.N:Identity[0] <[GHC.Types.Char]>_R)
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.$fShow(,)3
                                         (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))))) })
                     ls
                     s) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fShowOr ::
    (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Main.Or a b)
  DFunId
  {- Arity: 2,
     Strictness: <L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      (v :: GHC.Show.Show a)
                      (v1 :: GHC.Show.Show b).
                  @ (Main.Or a b)
                  (Main.$fShowOr_$cshowsPrec @ a @ b v v1)
                  (Main.$fShowOr_$cshow @ a @ b v v1)
                  (Main.$fShowOr_$cshowList @ a @ b v v1) -}
f1ca82ce2d08864d862db336c94fe651
  $fShowOr1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.$fShowOr2) -}
f3ffe02c57aa60b0177b0f8c86439976
  $fShowOr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Snd "#) -}
91ecd10d404499ad13faae6dc215f4f6
  $fShowOr3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.$fShowOr4) -}
b2b090a0b974d6da6f7ce225a835604f
  $fShowOr4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Fst "#) -}
d61dd1fb3c7e1d901a2baa86bdb80ceb
  $fShowOr5 ::
    Main.Or [GHC.Types.Char] Main.Trivial -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (w :: Main.Or [GHC.Types.Char] Main.Trivial)
                   (w1 :: GHC.Base.String) ->
                 Main.$w$s$cshowsPrec2 0# w w1) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fShowOr_$cshow ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    Main.Or a b -> GHC.Base.String
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show a)
                   ($dShow1 :: GHC.Show.Show b)
                   (x :: Main.Or a b) ->
                 case x of wild {
                   Main.Fst b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Main.$fShowOr3
                        (GHC.Show.showsPrec
                           @ a
                           $dShow
                           Main.$fShowFour1
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Main.Snd b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Main.$fShowOr1
                        (GHC.Show.showsPrec
                           @ b
                           $dShow1
                           Main.$fShowFour1
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fShowOr_$cshowList ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    [Main.Or a b] -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show a)
                   ($dShow1 :: GHC.Show.Show b)
                   (ls :: [Main.Or a b])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Or a b)
                   (Main.$fShowOr_$cshowsPrec @ a @ b $dShow $dShow1 Main.$fShowFour2)
                   ls
                   s) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fShowOr_$cshowsPrec ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    GHC.Types.Int -> Main.Or a b -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (w2 :: GHC.Types.Int)
                   (w3 :: Main.Or a b) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 Main.$w$cshowsPrec4 @ a @ b w w1 ww1 w3 }) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fShowOr_$s$cshow ::
    Main.Or [GHC.Types.Char] Main.Trivial -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Main.Or [GHC.Types.Char] Main.Trivial) ->
                 case x of wild {
                   Main.Fst b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Main.$fShowOr3
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.$fShow(,)3
                           (GHC.Show.showLitString b1 Main.$fShowFour8))
                   Main.Snd b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Main.$fShowOr1
                        (case b1 of wild1 { Main.Trivial -> Main.$fShowFour3 }) }) -}
82bec3c96ac3573812e03309a4719f3a
  $fShowOr_$s$cshowList ::
    [Main.Or [GHC.Types.Char] Main.Trivial] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.Or [GHC.Types.Char] Main.Trivial])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Or [GHC.Types.Char] Main.Trivial)
                   Main.$fShowOr5
                   ls
                   s) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fShowOr_$s$cshowsPrec ::
    GHC.Types.Int
    -> Main.Or [GHC.Types.Char] Main.Trivial -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Main.Or [GHC.Types.Char] Main.Trivial)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Main.$w$s$cshowsPrec2 ww1 w1 w2 }) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $fShowOr_$s$fShowOr ::
    GHC.Show.Show (Main.Or [GHC.Types.Char] Main.Trivial)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Main.Or [GHC.Types.Char] Main.Trivial)
                  Main.$fShowOr_$s$cshowsPrec
                  Main.$fShowOr_$s$cshow
                  (\ (ls :: [Main.Or [GHC.Types.Char] Main.Trivial])
                     (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (Main.Or [GHC.Types.Char] Main.Trivial)
                     (Main.$fShowOr_$s$cshowsPrec Main.$fShowFour2)
                     ls
                     s) -}
8be194816a28d8986f52eec848797f66
  $fShowThree ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) =>
    GHC.Show.Show (Main.Three a b c)
  DFunId
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      @ c
                      (v :: GHC.Show.Show a)
                      (v1 :: GHC.Show.Show b)
                      (v2 :: GHC.Show.Show c).
                  @ (Main.Three a b c)
                  (Main.$fShowThree_$cshowsPrec @ a @ b @ c v v1 v2)
                  (Main.$fShowThree_$cshow @ a @ b @ c v v1 v2)
                  (Main.$fShowThree_$cshowList @ a @ b @ c v v1 v2) -}
fad38c89914f686768556c4f6c51578d
  $fShowThree1 :: (GHC.Types.Char -> b -> b) -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ b
                   (c :: GHC.Types.Char -> b -> b)[OneShot]
                   (n :: b)[OneShot] ->
                 GHC.CString.unpackFoldrCString# @ b "Three "# c n) -}
84a6dc0e00c6bbb0bfd22bec9a8e7cc5
  $fShowThree2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Three "#) -}
9fe7fc64b2376e4274773df7ab867047
  $fShowThree3 ::
    Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(1*H,1*U,1*H)><L,U>,
     Unfolding: (\ (w :: Main.Three
                           Main.Trivial [GHC.Types.Char] Main.Trivial)
                   (w1 :: GHC.Base.String) ->
                 case w of ww { Main.Three ww1 ww2 ww3 ->
                 Main.$w$s$cshowsPrec3 0# ww1 ww2 ww3 w1 }) -}
8be194816a28d8986f52eec848797f66
  $fShowThree_$cshow ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) =>
    Main.Three a b c -> GHC.Base.String
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,1*U(U,U,U)>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   @ c
                   ($dShow :: GHC.Show.Show a)
                   ($dShow1 :: GHC.Show.Show b)
                   ($dShow2 :: GHC.Show.Show c)
                   (x :: Main.Three a b c) ->
                 Main.$fShowThree_$cshowsPrec
                   @ a
                   @ b
                   @ c
                   $dShow
                   $dShow1
                   $dShow2
                   Main.$fShowFour2
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8be194816a28d8986f52eec848797f66
  $fShowThree_$cshowList ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) =>
    [Main.Three a b c] -> GHC.Show.ShowS
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   @ c
                   ($dShow :: GHC.Show.Show a)
                   ($dShow1 :: GHC.Show.Show b)
                   ($dShow2 :: GHC.Show.Show c)
                   (ls :: [Main.Three a b c])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Three a b c)
                   (Main.$fShowThree_$cshowsPrec
                      @ a
                      @ b
                      @ c
                      $dShow
                      $dShow1
                      $dShow2
                      Main.$fShowFour2)
                   ls
                   s) -}
8be194816a28d8986f52eec848797f66
  $fShowThree_$cshowsPrec ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) =>
    GHC.Types.Int -> Main.Three a b c -> GHC.Show.ShowS
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   @ c
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (w2 :: GHC.Show.Show c)
                   (w3 :: GHC.Types.Int)
                   (w4 :: Main.Three a b c) ->
                 case w3 of ww { GHC.Types.I# ww1 ->
                 case w4 of ww2 { Main.Three ww3 ww4 ww5 ->
                 Main.$w$cshowsPrec5 @ a @ b @ c w w1 w2 ww1 ww3 ww4 ww5 } }) -}
6b488d11c8108da7c7a6d2cffebb5161
  $fShowThree_$s$cshow ::
    Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial
    -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*H,1*U,1*H)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial) ->
                 case w of ww { Main.Three ww1 ww2 ww3 ->
                 Main.$w$s$cshow1 ww1 ww2 ww3 }) -}
f5bcb7fc57fd53ec802a9c9d47222889
  $fShowThree_$s$cshowList ::
    [Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial]
    -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial)
                   Main.$fShowThree3
                   ls
                   s) -}
8be194816a28d8986f52eec848797f66
  $fShowThree_$s$cshowsPrec ::
    GHC.Types.Int
    -> Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*H,1*U,1*H)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Main.Three ww3 ww4 ww5 ->
                 Main.$w$s$cshowsPrec3 ww1 ww3 ww4 ww5 w2 } }) -}
8be194816a28d8986f52eec848797f66
  $fShowThree_$s$fShowThree ::
    GHC.Show.Show
      (Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial)
                  Main.$fShowThree_$s$cshowsPrec
                  (\ (x :: Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial) ->
                   case x of wild { Main.Three b1 b2 b3 ->
                   case GHC.Classes.geInt Main.$fShowFour2 Main.$fShowFour1 of wild1 {
                     GHC.Types.False
                     -> GHC.Base.augment
                          @ GHC.Types.Char
                          Main.$fShowThree1
                          (case b1 of wild2 { Main.Trivial ->
                           GHC.Base.augment
                             @ GHC.Types.Char
                             (\ @ b
                                (c :: GHC.Types.Char -> b -> b)[OneShot]
                                (n :: b)[OneShot] ->
                              GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowFour3)
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.showSpace1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.$fShow(,)3
                                   (GHC.Show.showLitString
                                      b2
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.$fShow(,)3
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.showSpace1
                                            (case b3 of wild3 { Main.Trivial ->
                                             GHC.Base.build
                                               @ GHC.Types.Char
                                               (\ @ b
                                                  (c :: GHC.Types.Char -> b -> b)[OneShot]
                                                  (n :: b)[OneShot] ->
                                                GHC.Base.foldr
                                                  @ GHC.Types.Char
                                                  @ b
                                                  c
                                                  n
                                                  Main.$fShowFour3) })))))) })
                     GHC.Types.True
                     -> GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.$fShow(,)4
                          (GHC.Base.augment
                             @ GHC.Types.Char
                             Main.$fShowThree1
                             (case b1 of wild2 { Main.Trivial ->
                              GHC.Base.augment
                                @ GHC.Types.Char
                                (\ @ b
                                   (c :: GHC.Types.Char -> b -> b)[OneShot]
                                   (n :: b)[OneShot] ->
                                 GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowFour3)
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)3
                                      (GHC.Show.showLitString
                                         b2
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.$fShow(,)3
                                            (GHC.Types.:
                                               @ GHC.Types.Char
                                               GHC.Show.showSpace1
                                               (case b3 of wild3 { Main.Trivial ->
                                                GHC.Base.augment
                                                  @ GHC.Types.Char
                                                  (\ @ b
                                                     (c :: GHC.Types.Char -> b -> b)[OneShot]
                                                     (n :: b)[OneShot] ->
                                                   GHC.Base.foldr
                                                     @ GHC.Types.Char
                                                     @ b
                                                     c
                                                     n
                                                     Main.$fShowFour3)
                                                  (GHC.Types.:
                                                     @ GHC.Types.Char
                                                     GHC.Show.$fShow(,)2
                                                     (GHC.Types.[]
                                                        @ GHC.Types.Char)) })))))) })) } })
                  (\ (ls :: [Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial])
                     (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial)
                     (Main.$fShowThree_$s$cshowsPrec Main.$fShowFour2)
                     ls
                     s) -}
45254d41351bf1a0f3b9fd85ef078bac
  $fShowTrivial :: GHC.Show.Show Main.Trivial
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Main.Trivial
                  Main.$fShowTrivial_$cshowsPrec
                  Main.$fShowTrivial_$cshow
                  Main.$fShowTrivial_$cshowList -}
45254d41351bf1a0f3b9fd85ef078bac
  $fShowTrivial1 :: Main.Trivial -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*H><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Main.Trivial) (eta :: GHC.Base.String) ->
                 case ds of wild { Main.Trivial ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowFour3)
                   eta }) -}
45254d41351bf1a0f3b9fd85ef078bac
  $fShowTrivial_$cshow :: Main.Trivial -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Main.Trivial) ->
                 case x of wild { Main.Trivial -> Main.$fShowFour3 }) -}
45254d41351bf1a0f3b9fd85ef078bac
  $fShowTrivial_$cshowList :: [Main.Trivial] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.Trivial]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Main.Trivial Main.$fShowTrivial1 ls s) -}
45254d41351bf1a0f3b9fd85ef078bac
  $fShowTrivial_$cshowsPrec ::
    GHC.Types.Int -> Main.Trivial -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*H><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Main.Trivial)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild { Main.Trivial ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowFour3)
                   eta }) -}
6915335e4f938e3f9ae253446cb392f1
  $fShowTwo ::
    (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Main.Two a b)
  DFunId
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ b
                      (v :: GHC.Show.Show a)
                      (v1 :: GHC.Show.Show b).
                  @ (Main.Two a b)
                  (Main.$fShowTwo_$cshowsPrec @ a @ b v v1)
                  (Main.$fShowTwo_$cshow @ a @ b v v1)
                  (Main.$fShowTwo_$cshowList @ a @ b v v1) -}
375bf166513be4f84dd2c3feccc4443f
  $fShowTwo1 :: (GHC.Types.Char -> b -> b) -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ b
                   (c :: GHC.Types.Char -> b -> b)[OneShot]
                   (n :: b)[OneShot] ->
                 GHC.CString.unpackFoldrCString# @ b "Two "# c n) -}
0077176ef96d7419766bbbc558be5bcd
  $fShowTwo2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Two "#) -}
2695bdff1c6254533b7e74ad60674a15
  $fShowTwo3 ::
    Main.Two Main.Trivial [GHC.Types.Char] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(1*H,1*U)><L,U>,
     Unfolding: (\ (w :: Main.Two Main.Trivial [GHC.Types.Char])
                   (w1 :: GHC.Base.String) ->
                 case w of ww { Main.Two ww1 ww2 ->
                 Main.$w$s$cshowsPrec4 0# ww1 ww2 w1 }) -}
6915335e4f938e3f9ae253446cb392f1
  $fShowTwo_$cshow ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    Main.Two a b -> GHC.Base.String
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show a)
                   ($dShow1 :: GHC.Show.Show b)
                   (x :: Main.Two a b) ->
                 Main.$fShowTwo_$cshowsPrec
                   @ a
                   @ b
                   $dShow
                   $dShow1
                   Main.$fShowFour2
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
6915335e4f938e3f9ae253446cb392f1
  $fShowTwo_$cshowList ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    [Main.Two a b] -> GHC.Show.ShowS
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(C(U))),A,A)><L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   ($dShow :: GHC.Show.Show a)
                   ($dShow1 :: GHC.Show.Show b)
                   (ls :: [Main.Two a b])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Two a b)
                   (Main.$fShowTwo_$cshowsPrec
                      @ a
                      @ b
                      $dShow
                      $dShow1
                      Main.$fShowFour2)
                   ls
                   s) -}
6915335e4f938e3f9ae253446cb392f1
  $fShowTwo_$cshowsPrec ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    GHC.Types.Int -> Main.Two a b -> GHC.Show.ShowS
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: [0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (w2 :: GHC.Types.Int)
                   (w3 :: Main.Two a b) ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 case w3 of ww2 { Main.Two ww3 ww4 ->
                 Main.$w$cshowsPrec6 @ a @ b w w1 ww1 ww3 ww4 } }) -}
43de4cbddeea31487069de3cb90d16de
  $fShowTwo_$s$cshow ::
    Main.Two Main.Trivial [GHC.Types.Char] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*H,1*U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Main.Two Main.Trivial [GHC.Types.Char]) ->
                 case w of ww { Main.Two ww1 ww2 -> Main.$w$s$cshow2 ww1 ww2 }) -}
9c86bc39e5605be8ef17d30840f0cdcf
  $fShowTwo_$s$cshowList ::
    [Main.Two Main.Trivial [GHC.Types.Char]] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.Two Main.Trivial [GHC.Types.Char]])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Two Main.Trivial [GHC.Types.Char])
                   Main.$fShowTwo3
                   ls
                   s) -}
6915335e4f938e3f9ae253446cb392f1
  $fShowTwo_$s$cshowsPrec ::
    GHC.Types.Int
    -> Main.Two Main.Trivial [GHC.Types.Char] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*H,1*U)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Main.Two Main.Trivial [GHC.Types.Char])
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Main.Two ww3 ww4 ->
                 Main.$w$s$cshowsPrec4 ww1 ww3 ww4 w2 } }) -}
6915335e4f938e3f9ae253446cb392f1
  $fShowTwo_$s$fShowTwo ::
    GHC.Show.Show (Main.Two Main.Trivial [GHC.Types.Char])
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Main.Two Main.Trivial [GHC.Types.Char])
                  Main.$fShowTwo_$s$cshowsPrec
                  (\ (x :: Main.Two Main.Trivial [GHC.Types.Char]) ->
                   case x of wild { Main.Two b1 b2 ->
                   case GHC.Classes.geInt Main.$fShowFour2 Main.$fShowFour1 of wild1 {
                     GHC.Types.False
                     -> GHC.Base.augment
                          @ GHC.Types.Char
                          Main.$fShowTwo1
                          (case b1 of wild2 { Main.Trivial ->
                           GHC.Base.augment
                             @ GHC.Types.Char
                             (\ @ b
                                (c :: GHC.Types.Char -> b -> b)[OneShot]
                                (n :: b)[OneShot] ->
                              GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowFour3)
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.showSpace1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.$fShow(,)3
                                   (GHC.Show.showLitString
                                      b2
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.$fShow(,)3
                                         (GHC.Types.[] @ GHC.Types.Char))))) })
                     GHC.Types.True
                     -> GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.$fShow(,)4
                          (GHC.Base.augment
                             @ GHC.Types.Char
                             Main.$fShowTwo1
                             (case b1 of wild2 { Main.Trivial ->
                              GHC.Base.augment
                                @ GHC.Types.Char
                                (\ @ b
                                   (c :: GHC.Types.Char -> b -> b)[OneShot]
                                   (n :: b)[OneShot] ->
                                 GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowFour3)
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)3
                                      (GHC.Show.showLitString
                                         b2
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.$fShow(,)3
                                            (GHC.Types.:
                                               @ GHC.Types.Char
                                               GHC.Show.$fShow(,)2
                                               (GHC.Types.[] @ GHC.Types.Char)))))) })) } })
                  (\ (ls :: [Main.Two Main.Trivial [GHC.Types.Char]])
                     (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (Main.Two Main.Trivial [GHC.Types.Char])
                     (Main.$fShowTwo_$s$cshowsPrec Main.$fShowFour2)
                     ls
                     s) -}
e041ecb75806a47731f00390b16e2886
  $s$fTestable(->)11 ::
    (Main.BoolDisj -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.BoolDisj -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable2 w ww1 ww2 ww3 ww4 w2 }) -}
88f027f1bf7938cab93653780da798af
  $s$fTestable(->)13 ::
    (Main.BoolDisj -> Main.BoolDisj -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.BoolDisj -> Main.BoolDisj -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable3 w ww1 ww2 ww3 ww4 w2 }) -}
71e5b5cfda5fb6524bca123537b119db
  $s$fTestable(->)15 ::
    (Main.BoolConj -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.BoolConj -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable4 w ww1 ww2 ww3 ww4 w2 }) -}
efb851a66b15248ee2a4334f919e5d52
  $s$fTestable(->)17 ::
    (Main.BoolConj -> Main.BoolConj -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.BoolConj -> Main.BoolConj -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable5 w ww1 ww2 ww3 ww4 w2 }) -}
5821fa6ade46a92906090caf8a817fcc
  $s$fTestable(->)24 ::
    (Main.Or GHC.Base.String Main.Trivial -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.Or GHC.Base.String Main.Trivial -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable6 w ww1 ww2 ww3 ww4 w2 }) -}
2f9ff6cba9b506ff587c3cf54b25e3a7
  $s$fTestable(->)25 ::
    Main.Or [GHC.Types.Char] Main.Trivial
    -> [Main.Or [GHC.Types.Char] Main.Trivial]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Main.Or [GHC.Types.Char] Main.Trivial) ->
                 GHC.Types.[] @ (Main.Or [GHC.Types.Char] Main.Trivial)) -}
e114e71d09a1bcd627c0b295befedef2
  $s$fTestable(->)27 ::
    (Main.Or GHC.Base.String Main.Trivial
     -> Main.Or GHC.Base.String Main.Trivial -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.Or GHC.Base.String Main.Trivial
                         -> Main.Or GHC.Base.String Main.Trivial -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable7 w ww1 ww2 ww3 ww4 w2 }) -}
fd908090f82ab6952a82b2b7fb38fb2f
  $s$fTestable(->)29 ::
    (Main.Four
       Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String
     -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.Four
                           Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String
                         -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable8 w ww1 ww2 ww3 ww4 w2 }) -}
b441e9ea49c37e621632523fd08ba999
  $s$fTestable(->)30 ::
    Main.Four
      Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char]
    -> [Main.Four
          Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char]]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Main.Four
                            Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char]) ->
                 GHC.Types.[]
                   @ (Main.Four
                        Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char])) -}
0e5d22966312801a044b10d36e434f95
  $s$fTestable(->)32 ::
    (Main.Four
       Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String
     -> Main.Four
          Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String
     -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.Four
                           Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String
                         -> Main.Four
                              Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String
                         -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable9 w ww1 ww2 ww3 ww4 w2 }) -}
8fa4583a16ac70fad48d889877d5cb26
  $s$fTestable(->)34 ::
    (Main.Three Main.Trivial GHC.Base.String Main.Trivial
     -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.Three Main.Trivial GHC.Base.String Main.Trivial
                         -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable10 w ww1 ww2 ww3 ww4 w2 }) -}
11c3a2c381059bd8de7bcdf99fe920b4
  $s$fTestable(->)35 ::
    Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial
    -> [Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial) ->
                 GHC.Types.[]
                   @ (Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial)) -}
fe4490b871da147e102d89fd61e786b2
  $s$fTestable(->)37 ::
    (Main.Three Main.Trivial GHC.Base.String Main.Trivial
     -> Main.Three Main.Trivial GHC.Base.String Main.Trivial
     -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.Three Main.Trivial GHC.Base.String Main.Trivial
                         -> Main.Three Main.Trivial GHC.Base.String Main.Trivial
                         -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable11 w ww1 ww2 ww3 ww4 w2 }) -}
e3b9244871e71b41f61e4c4d48cd375b
  $s$fTestable(->)39 ::
    (Main.Two Main.Trivial GHC.Base.String -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.Two Main.Trivial GHC.Base.String -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable12 w ww1 ww2 ww3 ww4 w2 }) -}
b3d4528e31d7c6143f9397eebd14526e
  $s$fTestable(->)40 ::
    Main.Two Main.Trivial [GHC.Types.Char]
    -> [Main.Two Main.Trivial [GHC.Types.Char]]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Main.Two Main.Trivial [GHC.Types.Char]) ->
                 GHC.Types.[] @ (Main.Two Main.Trivial [GHC.Types.Char])) -}
e8a16cc19f98ce07679bf26adfa6e702
  $s$fTestable(->)42 ::
    (Main.Two Main.Trivial GHC.Base.String
     -> Main.Two Main.Trivial GHC.Base.String -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.Two Main.Trivial GHC.Base.String
                         -> Main.Two Main.Trivial GHC.Base.String -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable13 w ww1 ww2 ww3 ww4 w2 }) -}
e730b86f967b30cc8be88eaaab9ef5a2
  $s$fTestable(->)44 ::
    (Main.Trivial -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.Trivial -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable14 w ww1 ww2 ww3 ww4 w2 }) -}
71974caf2f25b8006ad33bc01a6bf793
  $s$fTestable(->)46 ::
    (Main.Trivial -> Main.Trivial -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.Trivial -> Main.Trivial -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable15 w ww1 ww2 ww3 ww4 w2 }) -}
5878e5dab42bca4485714921eff58b64
  $s$fTestable(->)5 ::
    (Main.Identity GHC.Base.String
     -> Main.Identity GHC.Base.String -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.Identity GHC.Base.String
                         -> Main.Identity GHC.Base.String -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable w ww1 ww2 ww3 ww4 w2 }) -}
74f2ec07d8d00cdf82ebf6a4c384a0a4
  $s$fTestable(->)6 ::
    Main.Identity [GHC.Types.Char] -> [Main.Identity [GHC.Types.Char]]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Main.Identity [GHC.Types.Char]) ->
                 GHC.Types.[] @ (Main.Identity [GHC.Types.Char])) -}
e6aa24cb1c87edd05df146943b9e6a87
  $s$fTestable(->)7 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> Main.Identity [GHC.Types.Char]
  {- Arity: 2,
     Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><S(S),1*U(U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Test.QuickCheck.Random.QCGen) (w1 :: GHC.Types.Int) ->
                 case w `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case w1 of ww7 { GHC.Types.I# ww8 ->
                 Main.$wlvl ww1 ww2 ww3 ww4 ww8 } }) -}
7cea35ead76bbf22511f4e2fc3932270
  $s$fTestable(->)8 ::
    (Main.Identity GHC.Base.String -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.Identity GHC.Base.String -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable1 w ww1 ww2 ww3 ww4 w2 }) -}
3bb84c773ea26b59c3aa926eca90e47d
  $tc'BoolConj :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16218516835351857519##
                   8031704507718647831##
                   Main.$trModule
                   Main.$tc'BoolConj2
                   0#
                   Main.$tc'BoolConj1) -}
054c7674c0f2ab51f743f020ca5eae88
  $tc'BoolConj1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
bdf09c8540eb702c4b47635c48509d50
  $tc'BoolConj2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'BoolConj3) -}
286bd8717775bc938f8fdac48fa63d95
  $tc'BoolConj3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BoolConj"#) -}
015c6166799ef7fe6b643f1eff7d3a96
  $tc'BoolDisj :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2484730755614622937##
                   831860130603479529##
                   Main.$trModule
                   Main.$tc'BoolDisj2
                   0#
                   Main.$tc'BoolDisj1) -}
b55041b74c13bdbab18b060010260bef
  $tc'BoolDisj1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
0c04949384d6adc007856121c5b2d4c6
  $tc'BoolDisj2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'BoolDisj3) -}
66eb5ed949756bb6e8a42333afd92dcd
  $tc'BoolDisj3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'BoolDisj"#) -}
00c3df5467e16a4e8f2ddb7901757fe6
  $tc'Combine :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10229559240988272860##
                   11879814718072235938##
                   Main.$trModule
                   Main.$tc'Combine2
                   2#
                   Main.$tc'Combine1) -}
72aceea6be67c1540cd7e6dfe43d0a63
  $tc'Combine1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7e6a1cb1b8b4837b5f41440038a014fb
  $tc'Combine2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Combine3) -}
0e8bdb4931b0f53aeb18e12a850798bb
  $tc'Combine3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Combine"#) -}
40c7caacd13110f94db1d4bf5a292570
  $tc'Four :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17326434975074459781##
                   14106022890009699578##
                   Main.$trModule
                   Main.$tc'Four2
                   4#
                   Main.$tc'Four1) -}
f05ead26599cdd3a3fd0f781a55f3e83
  $tc'Four1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
73f62357fbafa87b22a3b1a5b6cc49df
  $tc'Four2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Four3) -}
89734812e2a2a9cca99a534b64935fca
  $tc'Four3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Four"#) -}
2609d9be22270b39482c48e296110a7a
  $tc'Fst :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   956857850585007361##
                   9245007750783337341##
                   Main.$trModule
                   Main.$tc'Fst2
                   2#
                   Main.$tc'Fst1) -}
fd23e4952543d7c26faedb7a0b2fbb31
  $tc'Fst1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
8aa39d092c538e31f0fbf3f3caa65e3b
  $tc'Fst2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Fst3) -}
baa65f70e30a8b5f3b1fc84c89c6cb4e
  $tc'Fst3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Fst"#) -}
0bd5949baa9edb5f640992311c2c884b
  $tc'Identity :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14933744756080264347##
                   10325705257141500534##
                   Main.$trModule
                   Main.$tc'Identity2
                   1#
                   Main.$tc'Identity1) -}
06dc3a95b0f8e52b98fab182ef8e5788
  $tc'Identity1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
c0dada2b15ae1f43367d2a7b838263f7
  $tc'Identity2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Identity3) -}
135186636ef9703f9f3dd552c37781d3
  $tc'Identity3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Identity"#) -}
2b6654de297aced0dc2afe5bb095d6c6
  $tc'Snd :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4809352157181647407##
                   10533052007724714236##
                   Main.$trModule
                   Main.$tc'Snd2
                   2#
                   Main.$tc'Snd1) -}
043ca292c8d75a674689f1ce5c3c2143
  $tc'Snd1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
99f5d42cc6112aced5c34b6ca3db78ec
  $tc'Snd2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Snd3) -}
770ab665bc752c7d2998efed38161261
  $tc'Snd3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Snd"#) -}
63b483d17ed0faa435cd1f30f0f97918
  $tc'Three :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1501002409485380506##
                   1865613145701371112##
                   Main.$trModule
                   Main.$tc'Three2
                   3#
                   Main.$tc'Three1) -}
582550797340c2a575a8b6196068e2f1
  $tc'Three1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
49d7da3e35bbd3886a7966b46d765bd3
  $tc'Three2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Three3) -}
ecfc6faf4ac30db884177d9dc9a0d006
  $tc'Three3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Three"#) -}
865596e2a382e2ffc4e2279f155fca86
  $tc'Trivial :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6457485729114745029##
                   3003837664020060680##
                   Main.$trModule
                   Main.$tc'Trivial2
                   0#
                   Main.$tc'Trivial1) -}
bf0003566bd066a9bceca4284b805808
  $tc'Trivial1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
ced5b10fb46dbe391811a136eba6ea94
  $tc'Trivial2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Trivial3) -}
6d59c0ee9fb6f34981689780a757bfe9
  $tc'Trivial3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Trivial"#) -}
af7e5c2c7aff56ddb76f82c12354dedd
  $tc'Two :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7581589987092827629##
                   15326290315829168296##
                   Main.$trModule
                   Main.$tc'Two2
                   2#
                   Main.$tc'Two1) -}
263c9ff8106bd8bcb42bd9cf5393dd06
  $tc'Two1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d993e58b5bc8d748892b5c5eba295026
  $tc'Two2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Two3) -}
7922cbd6d9971a2b40cd163a36de2a94
  $tc'Two3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Two"#) -}
5c16023f9d63291774015ea4533988d9
  $tcBoolConj :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14717413906963252735##
                   17642211729665078507##
                   Main.$trModule
                   Main.$tcBoolConj1
                   0#
                   GHC.Types.krep$*) -}
86810e84f39c4ddd3ec98bea99cbb882
  $tcBoolConj1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcBoolConj2) -}
00820d23d8fa2391366f96af5e5caedc
  $tcBoolConj2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BoolConj"#) -}
81027bd23317acb721e211de2087540b
  $tcBoolDisj :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12896167237427825229##
                   11939161457016289135##
                   Main.$trModule
                   Main.$tcBoolDisj1
                   0#
                   GHC.Types.krep$*) -}
526f1ed9288d25b9e0638bdf0aa47d75
  $tcBoolDisj1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcBoolDisj2) -}
023e86063b98e0a7e9573ecf58cb0ab0
  $tcBoolDisj2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("BoolDisj"#) -}
84f7172ef69472f72bf60937a94ccfda
  $tcCombine :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4945805439339505953##
                   16347234775349207955##
                   Main.$trModule
                   Main.$tcCombine1
                   0#
                   GHC.Types.krep$*->*->*) -}
87bfe949fdbbe10f2279824bb6a3e5fb
  $tcCombine1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcCombine2) -}
8f31fced0e94a105ff9752630775c939
  $tcCombine2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Combine"#) -}
78972b9554ef008e75a63d988f56b462
  $tcFour :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10259966408793098383##
                   10733803583214171053##
                   Main.$trModule
                   Main.$tcFour2
                   0#
                   Main.$tcFour1) -}
333cb6ce6ba53804c38a6d4d028d63e6
  $tcFour1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a5ad6e71741ae2277666b144db87be29
  $tcFour2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcFour3) -}
990e61337bd7313a51e3e5f4eeebecc4
  $tcFour3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Four"#) -}
28672504a208deaa7f40fff68130c41f
  $tcIdentity :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13554781859897037554##
                   14585010631131321658##
                   Main.$trModule
                   Main.$tcIdentity1
                   0#
                   GHC.Types.krep$*Arr*) -}
4f408214dfe53a1936d344880a32cd2f
  $tcIdentity1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcIdentity2) -}
e7a6f380740600ebf601298965149762
  $tcIdentity2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Identity"#) -}
6294f65911c407d119fbae04d8fa5dcd
  $tcOr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13918040407946096648##
                   2600731953473027776##
                   Main.$trModule
                   Main.$tcOr1
                   0#
                   GHC.Types.krep$*->*->*) -}
93c5422912403114bf0ab43421535ff6
  $tcOr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcOr2) -}
915882e27006ba399f7d8a8ab2bc5f46
  $tcOr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Or"#) -}
c8c56a32cad5db0e2df1dbc8f6f3c259
  $tcThree :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15576805238587676848##
                   8948308850007484541##
                   Main.$trModule
                   Main.$tcThree2
                   0#
                   Main.$tcThree1) -}
dfecd92c6e1e8b0b54ab8e351f83231c
  $tcThree1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
7056a5ebdc3a3efe7974d5b8d1f10852
  $tcThree2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcThree3) -}
0d90696dd8a3cfac597f6d323bc4ce22
  $tcThree3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Three"#) -}
d1a9c998c1c86250e13d5562ba65c094
  $tcTrivial :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1488722916004492003##
                   5561506386658536138##
                   Main.$trModule
                   Main.$tcTrivial1
                   0#
                   GHC.Types.krep$*) -}
4e3bd5a0a737cb2cd47bd7642204aeb1
  $tcTrivial1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$fShowFour4) -}
ca81e01de918985ec58e6b119a7d7465
  $tcTwo :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2801403543926488040##
                   2925450971047963023##
                   Main.$trModule
                   Main.$tcTwo1
                   0#
                   GHC.Types.krep$*->*->*) -}
603f5e42414c66fbfbd589a0ee49455e
  $tcTwo1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcTwo2) -}
da9b1d931c61c1a1efb3021b14514754
  $tcTwo2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Two"#) -}
be86c9d078d3acbf19ba91fe74a24273
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule3 Main.$trModule1) -}
b09d86f2c49dd5176b544d8d13ddb6c5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule2) -}
e5875966b74dad2d29772660b8a75e33
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Main"#) -}
23b03bd7d075a00f5ad1ee10e6add7b8
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule4) -}
d026be77cb9ced20e35a61514e0458aa
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
7b4600eecae4db57113d604726291026
  $w$c== ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) =>
    a -> b -> c -> a -> b -> c -> GHC.Types.Bool
  {- Arity: 9, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: GHC.Classes.Eq a)
                   (w1 :: GHC.Classes.Eq b)
                   (w2 :: GHC.Classes.Eq c)
                   (ww :: a)
                   (ww1 :: b)
                   (ww2 :: c)
                   (ww3 :: a)
                   (ww4 :: b)
                   (ww5 :: c) ->
                 case GHC.Classes.== @ a w ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.== @ b w1 ww1 ww4 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Classes.== @ c w2 ww2 ww5 } }) -}
9f5acecca13b9015eaa899a1e1fccefb
  $w$c==1 ::
    (GHC.Classes.Eq a, GHC.Classes.Eq b) =>
    a -> b -> a -> b -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Classes.Eq a)
                   (w1 :: GHC.Classes.Eq b)
                   (ww :: a)
                   (ww1 :: b)
                   (ww2 :: a)
                   (ww3 :: b) ->
                 case GHC.Classes.== @ a w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Classes.== @ b w1 ww1 ww3 }) -}
bf4612d7fb8db74c2d8581aaa51cfdf8
  $w$carbitrary ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b,
     Test.QuickCheck.Arbitrary.Arbitrary c,
     Test.QuickCheck.Arbitrary.Arbitrary d) =>
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> (# a, b, c, d #)
  {- Arity: 9, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   @ d
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (w2 :: Test.QuickCheck.Arbitrary.Arbitrary c)
                   (w3 :: Test.QuickCheck.Arbitrary.Arbitrary d)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w4 :: GHC.Types.Int) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 case ww9 of ww4 { System.Random.TF.Gen.TFGen ww5 ww6 ww10 ww11 ww12 ww13 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww5
                        ww6
                        ww10
                        ww11 of ww14 { (#,#) ww15 ww16 ->
                 case ww16 of ww17 { System.Random.TF.Gen.TFGen ww18 ww19 ww20 ww21 ww22 ww23 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww18
                        ww19
                        ww20
                        ww21 of ww24 { (#,#) ww25 ww26 ->
                 case ww26 of ww27 { System.Random.TF.Gen.TFGen ww28 ww29 ww30 ww31 ww32 ww33 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww28
                        ww29
                        ww30
                        ww31 of ww34 { (#,#) ww35 ww36 ->
                 (# (Test.QuickCheck.Arbitrary.arbitrary @ a w)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                      ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                      w4,
                    (Test.QuickCheck.Arbitrary.arbitrary @ b w1)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <b>_R)
                      ww15 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                      w4,
                    (Test.QuickCheck.Arbitrary.arbitrary @ c w2)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <c>_R)
                      ww25 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                      w4,
                    (Test.QuickCheck.Arbitrary.arbitrary @ d w3)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <d>_R)
                      ww35 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                      w4 #) } } } } } } }) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $w$carbitrary1 ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Main.Identity a
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 ((Test.QuickCheck.Arbitrary.arbitrary @ a w)
                    `cast`
                  (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                    ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                    w1)
                   `cast`
                 (Sym (Main.N:Identity[0] <a>_R)) }) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $w$carbitrary2 ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Main.Or a b
  {- Arity: 7,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w2 :: GHC.Types.Int) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 case ww9 of ww4 { System.Random.TF.Gen.TFGen ww5 ww6 ww10 ww11 ww12 ww13 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww5
                        ww6
                        ww10
                        ww11 of ww14 { (#,#) ww15 ww16 ->
                 (Test.QuickCheck.Gen.elements
                    @ (Main.Or a b)
                    (GHC.Types.:
                       @ (Main.Or a b)
                       (Main.Fst
                          @ a
                          @ b
                          ((Test.QuickCheck.Arbitrary.arbitrary @ a w)
                             `cast`
                           (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                             ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                             w2))
                       (GHC.Types.:
                          @ (Main.Or a b)
                          (Main.Snd
                             @ a
                             @ b
                             ((Test.QuickCheck.Arbitrary.arbitrary @ b w1)
                                `cast`
                              (Test.QuickCheck.Gen.N:Gen[0] <b>_R)
                                ww15 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                                w2))
                          (GHC.Types.[] @ (Main.Or a b)))))
                   `cast`
                 (Test.QuickCheck.Gen.N:Gen[0] <Main.Or a b>_R)
                   ww16 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                   w2 } } }) -}
74cedfd6d013737da36491f699e25e6a
  $w$carbitrary3 ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b,
     Test.QuickCheck.Arbitrary.Arbitrary c) =>
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> (# a, b, c #)
  {- Arity: 8, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (w2 :: Test.QuickCheck.Arbitrary.Arbitrary c)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w3 :: GHC.Types.Int) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 case ww9 of ww4 { System.Random.TF.Gen.TFGen ww5 ww6 ww10 ww11 ww12 ww13 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww5
                        ww6
                        ww10
                        ww11 of ww14 { (#,#) ww15 ww16 ->
                 case ww16 of ww17 { System.Random.TF.Gen.TFGen ww18 ww19 ww20 ww21 ww22 ww23 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww18
                        ww19
                        ww20
                        ww21 of ww24 { (#,#) ww25 ww26 ->
                 (# (Test.QuickCheck.Arbitrary.arbitrary @ a w)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                      ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                      w3,
                    (Test.QuickCheck.Arbitrary.arbitrary @ b w1)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <b>_R)
                      ww15 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                      w3,
                    (Test.QuickCheck.Arbitrary.arbitrary @ c w2)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <c>_R)
                      ww25 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                      w3 #) } } } } }) -}
3e1b825c7ad5627b8a9d64cd93aa59d6
  $w$carbitrary4 ::
    (Test.QuickCheck.Arbitrary.Arbitrary a,
     Test.QuickCheck.Arbitrary.Arbitrary b) =>
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> (# a, b #)
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><L,1*U(1*C1(C1(U)),A)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Arbitrary.Arbitrary b)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w2 :: GHC.Types.Int) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 case ww9 of ww4 { System.Random.TF.Gen.TFGen ww5 ww6 ww10 ww11 ww12 ww13 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww5
                        ww6
                        ww10
                        ww11 of ww14 { (#,#) ww15 ww16 ->
                 (# (Test.QuickCheck.Arbitrary.arbitrary @ a w)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                      ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                      w2,
                    (Test.QuickCheck.Arbitrary.arbitrary @ b w1)
                      `cast`
                    (Test.QuickCheck.Gen.N:Gen[0] <b>_R)
                      ww15 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                      w2 #) } } }) -}
bbe5f09bbf3262cb0ffd25ca31cd894e
  $w$csconcat ::
    GHC.Base.Semigroup b =>
    Main.Combine a b -> [Main.Combine a b] -> Main.Combine a b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Base.Semigroup b)
                   (ww :: Main.Combine a b)
                   (ww1 :: [Main.Combine a b]) ->
                 letrec {
                   go :: Main.Combine a b -> [Main.Combine a b] -> Main.Combine a b
                     {- Arity: 2, Strictness: <L,U><S,1*U> -}
                   = \ (b1 :: Main.Combine a b) (ds1 :: [Main.Combine a b]) ->
                     case ds1 of wild1 {
                       [] -> b1
                       : c cs
                       -> let {
                            ds :: Main.Combine a b = go c cs
                          } in
                          (\ (eta :: a) ->
                           GHC.Base.$fSemigroup(->)_$c<>
                             @ b
                             @ a
                             w
                             b1 `cast` (Main.N:Combine[0] <a>_N <b>_N)
                             ds `cast` (Main.N:Combine[0] <a>_N <b>_N)
                             eta)
                            `cast`
                          (Sym (Main.N:Combine[0]) <a>_N <b>_N) }
                 } in
                 go ww ww1) -}
71ca1b5b4596959890806ef0546c868c
  $w$csconcat1 ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c,
     GHC.Base.Semigroup d) =>
    a -> b -> c -> d -> [Main.Four a b c d] -> (# a, b, c, d #)
  {- Arity: 9, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><L,U><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   @ d
                   (w :: GHC.Base.Semigroup a)
                   (w1 :: GHC.Base.Semigroup b)
                   (w2 :: GHC.Base.Semigroup c)
                   (w3 :: GHC.Base.Semigroup d)
                   (ww :: a)
                   (ww1 :: b)
                   (ww2 :: c)
                   (ww3 :: d)
                   (ww4 :: [Main.Four a b c d]) ->
                 letrec {
                   $wgo :: a -> b -> c -> d -> [Main.Four a b c d] -> (# a, b, c, d #)
                     {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,1*U>,
                        Inline: [0] -}
                   = \ (ww5 :: a)
                       (ww6 :: b)
                       (ww7 :: c)
                       (ww8 :: d)
                       (w4 :: [Main.Four a b c d]) ->
                     case w4 of wild1 {
                       [] -> (# ww5, ww6, ww7, ww8 #)
                       : c1 cs
                       -> case c1 of ww9 { Main.Four ww10 ww11 ww12 ww13 ->
                          case $wgo
                                 ww10
                                 ww11
                                 ww12
                                 ww13
                                 cs of ww14 { (#,,,#) ww15 ww16 ww17 ww18 ->
                          (# GHC.Base.<> @ a w ww5 ww15, GHC.Base.<> @ b w1 ww6 ww16,
                             GHC.Base.<> @ c w2 ww7 ww17, GHC.Base.<> @ d w3 ww8 ww18 #) } } }
                 } in
                 $wgo ww ww1 ww2 ww3 ww4) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $w$csconcat2 ::
    GHC.Base.Semigroup a =>
    Main.Identity a -> [Main.Identity a] -> Main.Identity a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Base.Semigroup a)
                   (ww :: Main.Identity a)
                   (ww1 :: [Main.Identity a]) ->
                 letrec {
                   go :: Main.Identity a -> [Main.Identity a] -> Main.Identity a
                     {- Arity: 2, Strictness: <L,U><S,1*U> -}
                   = \ (b :: Main.Identity a) (ds1 :: [Main.Identity a]) ->
                     case ds1 of wild1 {
                       [] -> b
                       : c cs
                       -> (GHC.Base.<>
                             @ a
                             w
                             b `cast` (Main.N:Identity[0] <a>_R)
                             (go c cs) `cast` (Main.N:Identity[0] <a>_R))
                            `cast`
                          (Sym (Main.N:Identity[0] <a>_R)) }
                 } in
                 go ww ww1) -}
8be194816a28d8986f52eec848797f66
  $w$csconcat3 ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b,
     GHC.Base.Semigroup c) =>
    a -> b -> c -> [Main.Three a b c] -> (# a, b, c #)
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: GHC.Base.Semigroup a)
                   (w1 :: GHC.Base.Semigroup b)
                   (w2 :: GHC.Base.Semigroup c)
                   (ww :: a)
                   (ww1 :: b)
                   (ww2 :: c)
                   (ww3 :: [Main.Three a b c]) ->
                 letrec {
                   $wgo :: a -> b -> c -> [Main.Three a b c] -> (# a, b, c #)
                     {- Arity: 4, Strictness: <L,U><L,U><L,U><S,1*U>, Inline: [0] -}
                   = \ (ww4 :: a) (ww5 :: b) (ww6 :: c) (w3 :: [Main.Three a b c]) ->
                     case w3 of wild1 {
                       [] -> (# ww4, ww5, ww6 #)
                       : c1 cs
                       -> case c1 of ww7 { Main.Three ww8 ww9 ww10 ->
                          case $wgo ww8 ww9 ww10 cs of ww11 { (#,,#) ww12 ww13 ww14 ->
                          (# GHC.Base.<> @ a w ww4 ww12, GHC.Base.<> @ b w1 ww5 ww13,
                             GHC.Base.<> @ c w2 ww6 ww14 #) } } }
                 } in
                 $wgo ww ww1 ww2 ww3) -}
6915335e4f938e3f9ae253446cb392f1
  $w$csconcat4 ::
    (GHC.Base.Semigroup a, GHC.Base.Semigroup b) =>
    a -> b -> [Main.Two a b] -> (# a, b #)
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><L,U(C(C1(U)),A,A)><L,U><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Base.Semigroup a)
                   (w1 :: GHC.Base.Semigroup b)
                   (ww :: a)
                   (ww1 :: b)
                   (ww2 :: [Main.Two a b]) ->
                 letrec {
                   $wgo :: a -> b -> [Main.Two a b] -> (# a, b #)
                     {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
                   = \ (ww3 :: a) (ww4 :: b) (w2 :: [Main.Two a b]) ->
                     case w2 of wild1 {
                       [] -> (# ww3, ww4 #)
                       : c cs
                       -> case c of ww5 { Main.Two ww6 ww7 ->
                          case $wgo ww6 ww7 cs of ww8 { (#,#) ww9 ww10 ->
                          (# GHC.Base.<> @ a w ww3 ww9, GHC.Base.<> @ b w1 ww4 ww10 #) } } }
                 } in
                 $wgo ww ww1 ww2) -}
f81c90c9fc05e6c9348caba94b8766c2
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> Main.BoolConj -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Main.BoolConj)
                   (w1 :: GHC.Base.String) ->
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> GHC.CString.unpackAppendCString#
                        Main.$fShowBoolConj2
                        (case w `cast` (Main.N:BoolConj[0]) of wild {
                           GHC.Types.False
                           -> GHC.Base.++ @ GHC.Types.Char GHC.Show.$fShowBool4 w1
                           GHC.Types.True
                           -> GHC.Base.++ @ GHC.Types.Char GHC.Show.$fShowBool2 w1 })
                   1#
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Main.$fShowBoolConj2
                           (case w `cast` (Main.N:BoolConj[0]) of wild {
                              GHC.Types.False
                              -> GHC.Base.++
                                   @ GHC.Types.Char
                                   GHC.Show.$fShowBool4
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w1)
                              GHC.Types.True
                              -> GHC.Base.++
                                   @ GHC.Types.Char
                                   GHC.Show.$fShowBool2
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w1) })) }) -}
d4080385790f1b1c227a648ea8e737f2
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> Main.BoolDisj -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Main.BoolDisj)
                   (w1 :: GHC.Base.String) ->
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> GHC.CString.unpackAppendCString#
                        Main.$fShowBoolDisj2
                        (case w `cast` (Main.N:BoolDisj[0]) of wild {
                           GHC.Types.False
                           -> GHC.Base.++ @ GHC.Types.Char GHC.Show.$fShowBool4 w1
                           GHC.Types.True
                           -> GHC.Base.++ @ GHC.Types.Char GHC.Show.$fShowBool2 w1 })
                   1#
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Main.$fShowBoolDisj2
                           (case w `cast` (Main.N:BoolDisj[0]) of wild {
                              GHC.Types.False
                              -> GHC.Base.++
                                   @ GHC.Types.Char
                                   GHC.Show.$fShowBool4
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w1)
                              GHC.Types.True
                              -> GHC.Base.++
                                   @ GHC.Types.Char
                                   GHC.Show.$fShowBool2
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w1) })) }) -}
36f20fdc479296434715e1d2033b8a55
  $w$cshowsPrec2 ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c,
     GHC.Show.Show d) =>
    GHC.Prim.Int# -> a -> b -> c -> d -> GHC.Show.ShowS
  {- Arity: 9, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   @ d
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (w2 :: GHC.Show.Show c)
                   (w3 :: GHC.Show.Show d)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: a)
                   (ww2 :: b)
                   (ww3 :: c)
                   (ww4 :: d) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w Main.$fShowFour1 ww1
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ b w1 Main.$fShowFour1 ww2
                 } in
                 let {
                   f2 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ c w2 Main.$fShowFour1 ww3
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ d w3 Main.$fShowFour1 ww4
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.CString.unpackAppendCString#
                       Main.$fShowFour6
                       (f (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (f1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.showSpace1
                                   (f2 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))))))
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT -> p
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x)) }) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $w$cshowsPrec3 ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> Main.Identity a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Main.Identity a) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec
                       @ a
                       w
                       Main.$fShowFour1
                       w1 `cast` (Main.N:Identity[0] <a>_R)
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++ @ GHC.Types.Char Main.$fShowIdentity2 (g x)
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Main.$fShowIdentity2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $w$cshowsPrec4 ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    GHC.Prim.Int# -> Main.Or a b -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (ww :: GHC.Prim.Int#)
                   (w2 :: Main.Or a b) ->
                 case w2 of wild {
                   Main.Fst b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a w Main.$fShowFour1 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Main.$fShowOr3 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Main.$fShowOr3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   Main.Snd b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ b w1 Main.$fShowFour1 b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Main.$fShowOr1 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Main.$fShowOr1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
0b696914642a8c5cf681d5b526b5ccfd
  $w$cshowsPrec5 ::
    (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) =>
    GHC.Prim.Int# -> a -> b -> c -> GHC.Show.ShowS
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   @ c
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (w2 :: GHC.Show.Show c)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: a)
                   (ww2 :: b)
                   (ww3 :: c) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w Main.$fShowFour1 ww1
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ b w1 Main.$fShowFour1 ww2
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ c w2 Main.$fShowFour1 ww3
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        Main.$fShowThree2
                        (f (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.showSpace1
                              (f1 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))))
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Main.$fShowThree2
                           (f (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (f1
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.showSpace1
                                       (g (GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.$fShow(,)2
                                             x))))))) }) -}
aae587b3fd57f128e4dcb7bdd2961708
  $w$cshowsPrec6 ::
    (GHC.Show.Show a, GHC.Show.Show b) =>
    GHC.Prim.Int# -> a -> b -> GHC.Show.ShowS
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Show.Show b)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: a)
                   (ww2 :: b) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w Main.$fShowFour1 ww1
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ b w1 Main.$fShowFour1 ww2
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        Main.$fShowTwo2
                        (f (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Main.$fShowTwo2
                           (f (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showSpace1
                                 (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))))) }) -}
bbe5f09bbf3262cb0ffd25ca31cd894e
  $w$cstimes ::
    GHC.Base.Semigroup b =>
    forall b1.
    GHC.Real.Integral b1 =>
    b1 -> Main.Combine a b -> Main.Combine a b
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U>, Inline: [0] -}
b15724ae2a24ba7a7851a5a2aa5fb4a5
  $w$dTestable ::
    (Main.Identity GHC.Base.String
     -> Main.Identity GHC.Base.String -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.Identity GHC.Base.String
                         -> Main.Identity GHC.Base.String -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ (Main.Identity GHC.Base.String)
                   @ (Main.Identity GHC.Base.String -> GHC.Types.Bool)
                   Main.$fShowIdentity_$s$fShowIdentity
                   Main.$s$fTestable(->)8
                     `cast`
                   ((<Main.Identity GHC.Base.String -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <Main.Identity
                                                                                                                                       GHC.Base.String
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Main.$s$fTestable(->)7
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Main.Identity [GHC.Types.Char]>_R))
                   Main.$s$fTestable(->)6
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
601e0c13af852490bf93c5d73d34f1aa
  $w$dTestable1 ::
    (Main.Identity GHC.Base.String -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.Identity GHC.Base.String
                         -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ (Main.Identity GHC.Base.String)
                   @ GHC.Types.Bool
                   Main.$fShowIdentity_$s$fShowIdentity
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Main.$s$fTestable(->)7
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Main.Identity [GHC.Types.Char]>_R))
                   Main.$s$fTestable(->)6
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
7b5ede8ca0820f66a9847eb6255927da
  $w$dTestable10 ::
    (Main.Three Main.Trivial GHC.Base.String Main.Trivial
     -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.Three
                           Main.Trivial GHC.Base.String Main.Trivial
                         -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ (Main.Three Main.Trivial GHC.Base.String Main.Trivial)
                   @ GHC.Types.Bool
                   Main.$fShowThree_$s$fShowThree
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Main.$fArbitraryThree_$s$carbitrary
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial>_R))
                   Main.$s$fTestable(->)35
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
f0cc3e39860f0fb0067400fc2e8be66c
  $w$dTestable11 ::
    (Main.Three Main.Trivial GHC.Base.String Main.Trivial
     -> Main.Three Main.Trivial GHC.Base.String Main.Trivial
     -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.Three
                           Main.Trivial GHC.Base.String Main.Trivial
                         -> Main.Three Main.Trivial GHC.Base.String Main.Trivial
                         -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ (Main.Three Main.Trivial GHC.Base.String Main.Trivial)
                   @ (Main.Three Main.Trivial GHC.Base.String Main.Trivial
                      -> GHC.Types.Bool)
                   Main.$fShowThree_$s$fShowThree
                   Main.$s$fTestable(->)34
                     `cast`
                   ((<Main.Three Main.Trivial GHC.Base.String Main.Trivial
                      -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <Main.Three
                                                                                                                                       Main.Trivial
                                                                                                                                       GHC.Base.String
                                                                                                                                       Main.Trivial
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Main.$fArbitraryThree_$s$carbitrary
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Main.Three Main.Trivial [GHC.Types.Char] Main.Trivial>_R))
                   Main.$s$fTestable(->)35
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
12d312d885426e25af5a9ae8be26aed3
  $w$dTestable12 ::
    (Main.Two Main.Trivial GHC.Base.String -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.Two Main.Trivial GHC.Base.String
                         -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ (Main.Two Main.Trivial GHC.Base.String)
                   @ GHC.Types.Bool
                   Main.$fShowTwo_$s$fShowTwo
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Main.$fArbitraryTwo_$s$carbitrary
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Main.Two Main.Trivial [GHC.Types.Char]>_R))
                   Main.$s$fTestable(->)40
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
5a8b45f22d25dd26093b84cb3cd69b46
  $w$dTestable13 ::
    (Main.Two Main.Trivial GHC.Base.String
     -> Main.Two Main.Trivial GHC.Base.String -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.Two Main.Trivial GHC.Base.String
                         -> Main.Two Main.Trivial GHC.Base.String -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ (Main.Two Main.Trivial GHC.Base.String)
                   @ (Main.Two Main.Trivial GHC.Base.String -> GHC.Types.Bool)
                   Main.$fShowTwo_$s$fShowTwo
                   Main.$s$fTestable(->)39
                     `cast`
                   ((<Main.Two Main.Trivial GHC.Base.String -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <Main.Two
                                                                                                                                       Main.Trivial
                                                                                                                                       GHC.Base.String
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Main.$fArbitraryTwo_$s$carbitrary
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Main.Two Main.Trivial [GHC.Types.Char]>_R))
                   Main.$s$fTestable(->)40
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
8094f5ac795e27c95ee0913e79d0f91f
  $w$dTestable14 ::
    (Main.Trivial -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.Trivial -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ Main.Trivial
                   @ GHC.Types.Bool
                   Main.$fShowTrivial
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Main.$fArbitraryTrivial1
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.Trivial>_R))
                   Main.$fArbitraryTrivial_$cshrink
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
4ae491f95129477384365072875a29f2
  $w$dTestable15 ::
    (Main.Trivial -> Main.Trivial -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.Trivial -> Main.Trivial -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ Main.Trivial
                   @ (Main.Trivial -> GHC.Types.Bool)
                   Main.$fShowTrivial
                   Main.$s$fTestable(->)44
                     `cast`
                   ((<Main.Trivial -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <Main.Trivial
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Main.$fArbitraryTrivial1
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.Trivial>_R))
                   Main.$fArbitraryTrivial_$cshrink
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
60af41e992c2414154d36b459382d798
  $w$dTestable2 ::
    (Main.BoolDisj -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.BoolDisj -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ Main.BoolDisj
                   @ GHC.Types.Bool
                   Main.$fShowBoolDisj
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Main.$fArbitraryBoolDisj1
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.BoolDisj>_R))
                   Main.$fArbitraryBoolDisj_$cshrink
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
200d6c9a40b37ba808b8029a33b95df2
  $w$dTestable3 ::
    (Main.BoolDisj -> Main.BoolDisj -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.BoolDisj
                         -> Main.BoolDisj -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ Main.BoolDisj
                   @ (Main.BoolDisj -> GHC.Types.Bool)
                   Main.$fShowBoolDisj
                   Main.$s$fTestable(->)11
                     `cast`
                   ((<Main.BoolDisj -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <Main.BoolDisj
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Main.$fArbitraryBoolDisj1
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.BoolDisj>_R))
                   Main.$fArbitraryBoolDisj_$cshrink
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
20ece11be129fd67115c4db2fdf93d15
  $w$dTestable4 ::
    (Main.BoolConj -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.BoolConj -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ Main.BoolConj
                   @ GHC.Types.Bool
                   Main.$fShowBoolConj
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Main.$fArbitraryBoolConj1
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.BoolConj>_R))
                   Main.$fArbitraryBoolConj_$cshrink
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
93ab182d79d971d62d97372a9d3e2023
  $w$dTestable5 ::
    (Main.BoolConj -> Main.BoolConj -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.BoolConj
                         -> Main.BoolConj -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ Main.BoolConj
                   @ (Main.BoolConj -> GHC.Types.Bool)
                   Main.$fShowBoolConj
                   Main.$s$fTestable(->)15
                     `cast`
                   ((<Main.BoolConj -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <Main.BoolConj
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Main.$fArbitraryBoolConj1
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.BoolConj>_R))
                   Main.$fArbitraryBoolConj_$cshrink
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
a38833bde84f5fba5c83cc9c53ac6383
  $w$dTestable6 ::
    (Main.Or GHC.Base.String Main.Trivial -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.Or GHC.Base.String Main.Trivial
                         -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ (Main.Or GHC.Base.String Main.Trivial)
                   @ GHC.Types.Bool
                   Main.$fShowOr_$s$fShowOr
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Main.$fArbitraryOr_$s$carbitrary
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Main.Or [GHC.Types.Char] Main.Trivial>_R))
                   Main.$s$fTestable(->)25
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
5c26fa1736e2518e331bb05e6fe2fc22
  $w$dTestable7 ::
    (Main.Or GHC.Base.String Main.Trivial
     -> Main.Or GHC.Base.String Main.Trivial -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.Or GHC.Base.String Main.Trivial
                         -> Main.Or GHC.Base.String Main.Trivial -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ (Main.Or GHC.Base.String Main.Trivial)
                   @ (Main.Or GHC.Base.String Main.Trivial -> GHC.Types.Bool)
                   Main.$fShowOr_$s$fShowOr
                   Main.$s$fTestable(->)24
                     `cast`
                   ((<Main.Or GHC.Base.String Main.Trivial -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <Main.Or
                                                                                                                                       GHC.Base.String
                                                                                                                                       Main.Trivial
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Main.$fArbitraryOr_$s$carbitrary
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Main.Or [GHC.Types.Char] Main.Trivial>_R))
                   Main.$s$fTestable(->)25
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
8b267892e989798b31fadabacabcfb1f
  $w$dTestable8 ::
    (Main.Four
       Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String
     -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.Four
                           Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String
                         -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ (Main.Four
                        Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String)
                   @ GHC.Types.Bool
                   Main.$fShowFour_$s$fShowFour
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Main.$fArbitraryFour_$s$carbitrary
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Main.Four
                                Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char]>_R))
                   Main.$s$fTestable(->)30
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
f604853186161fc481abf718b3260cb0
  $w$dTestable9 ::
    (Main.Four
       Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String
     -> Main.Four
          Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String
     -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.Four
                           Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String
                         -> Main.Four
                              Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String
                         -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ (Main.Four
                        Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String)
                   @ (Main.Four
                        Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String
                      -> GHC.Types.Bool)
                   Main.$fShowFour_$s$fShowFour
                   Main.$s$fTestable(->)29
                     `cast`
                   ((<Main.Four
                        Main.Trivial GHC.Base.String Main.Trivial GHC.Base.String
                      -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <Main.Four
                                                                                                                                       Main.Trivial
                                                                                                                                       GHC.Base.String
                                                                                                                                       Main.Trivial
                                                                                                                                       GHC.Base.String
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Main.$fArbitraryFour_$s$carbitrary
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Main.Four
                                Main.Trivial [GHC.Types.Char] Main.Trivial [GHC.Types.Char]>_R))
                   Main.$s$fTestable(->)30
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
0b923f0ffa7d19b132767d5dc053d6b2
  $w$s$carbitrary ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> (# Main.Trivial, [GHC.Types.Char], Main.Trivial,
          [GHC.Types.Char] #)
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,1*U><L,U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: GHC.Types.Int) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 case ww9 of ww4 { System.Random.TF.Gen.TFGen ww5 ww6 ww10 ww11 ww12 ww13 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww5
                        ww6
                        ww10
                        ww11 of ww14 { (#,#) ww15 ww16 ->
                 case ww16 of ww17 { System.Random.TF.Gen.TFGen ww18 ww19 ww20 ww21 ww22 ww23 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww18
                        ww19
                        ww20
                        ww21 of ww24 { (#,#) ww25 ww26 ->
                 case ww26 of ww27 { System.Random.TF.Gen.TFGen ww28 ww29 ww30 ww31 ww32 ww33 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww28
                        ww29
                        ww30
                        ww31 of ww34 { (#,#) ww35 ww36 ->
                 (# Main.Trivial,
                    case ww15 of ww37 { System.Random.TF.Gen.TFGen ww38 ww39 ww40 ww41 ww42 ww43 ->
                    case w of ww44 { GHC.Types.I# ww45 ->
                    Test.QuickCheck.Gen.$wlistOf
                      @ GHC.Types.Char
                      Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
                      ww38
                      ww39
                      ww40
                      ww41
                      ww45 } },
                    Main.Trivial,
                    case ww35 of ww37 { System.Random.TF.Gen.TFGen ww38 ww39 ww40 ww41 ww42 ww43 ->
                    case w of ww44 { GHC.Types.I# ww45 ->
                    Test.QuickCheck.Gen.$wlistOf
                      @ GHC.Types.Char
                      Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
                      ww38
                      ww39
                      ww40
                      ww41
                      ww45 } } #) } } } } } } }) -}
7d46206135f54403eda14831d0008a35
  $w$s$carbitrary1 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Main.Or [GHC.Types.Char] Main.Trivial
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,1*U><L,U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: GHC.Types.Int) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 case ww9 of ww4 { System.Random.TF.Gen.TFGen ww5 ww6 ww10 ww11 ww12 ww13 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww5
                        ww6
                        ww10
                        ww11 of ww14 { (#,#) ww15 ww16 ->
                 (Test.QuickCheck.Gen.elements
                    @ (Main.Or [GHC.Types.Char] Main.Trivial)
                    (GHC.Types.:
                       @ (Main.Or [GHC.Types.Char] Main.Trivial)
                       (Main.Fst
                          @ [GHC.Types.Char]
                          @ Main.Trivial
                          (case ww8 of ww17 { System.Random.TF.Gen.TFGen ww18 ww19 ww20 ww21 ww22 ww23 ->
                           case w of ww24 { GHC.Types.I# ww25 ->
                           Test.QuickCheck.Gen.$wlistOf
                             @ GHC.Types.Char
                             Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
                             ww18
                             ww19
                             ww20
                             ww21
                             ww25 } }))
                       Main.$fArbitraryOr2))
                   `cast`
                 (Test.QuickCheck.Gen.N:Gen[0]
                      <Main.Or [GHC.Types.Char] Main.Trivial>_R)
                   ww16 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                   w } } }) -}
55f2fa7d437f2c0ad47bcac1ed08791d
  $w$s$carbitrary2 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> (# Main.Trivial, [GHC.Types.Char], Main.Trivial #)
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,1*U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: GHC.Types.Int) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 case ww9 of ww4 { System.Random.TF.Gen.TFGen ww5 ww6 ww10 ww11 ww12 ww13 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww5
                        ww6
                        ww10
                        ww11 of ww14 { (#,#) ww15 ww16 ->
                 case ww16 of ww17 { System.Random.TF.Gen.TFGen ww18 ww19 ww20 ww21 ww22 ww23 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww18
                        ww19
                        ww20
                        ww21 of ww24 { (#,#) ww25 ww26 ->
                 (# Main.Trivial,
                    case ww15 of ww27 { System.Random.TF.Gen.TFGen ww28 ww29 ww30 ww31 ww32 ww33 ->
                    case w of ww34 { GHC.Types.I# ww35 ->
                    Test.QuickCheck.Gen.$wlistOf
                      @ GHC.Types.Char
                      Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
                      ww28
                      ww29
                      ww30
                      ww31
                      ww35 } },
                    Main.Trivial #) } } } } }) -}
52fcea190df7162b87ee5a210f9013b5
  $w$s$carbitrary3 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> (# Main.Trivial, [GHC.Types.Char] #)
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,1*U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: GHC.Types.Int) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 case ww9 of ww4 { System.Random.TF.Gen.TFGen ww5 ww6 ww10 ww11 ww12 ww13 ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww5
                        ww6
                        ww10
                        ww11 of ww14 { (#,#) ww15 ww16 ->
                 (# Main.Trivial,
                    case ww15 of ww17 { System.Random.TF.Gen.TFGen ww18 ww19 ww20 ww21 ww22 ww23 ->
                    case w of ww24 { GHC.Types.I# ww25 ->
                    Test.QuickCheck.Gen.$wlistOf
                      @ GHC.Types.Char
                      Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
                      ww18
                      ww19
                      ww20
                      ww21
                      ww25 } } #) } } }) -}
f80ebae013b52d55808defb1837fec3e
  $w$s$cshow ::
    Main.Trivial
    -> [GHC.Types.Char]
    -> Main.Trivial
    -> [GHC.Types.Char]
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,1*H><L,1*U><L,1*H><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Main.Trivial)
                   (ww1 :: [GHC.Types.Char])
                   (ww2 :: Main.Trivial)
                   (ww3 :: [GHC.Types.Char]) ->
                 GHC.CString.unpackAppendCString#
                   Main.$fShowFour6
                   (case ww of wild { Main.Trivial ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      Main.$fShowFour3
                      (GHC.Types.:
                         @ GHC.Types.Char
                         GHC.Show.showSpace1
                         (GHC.Types.:
                            @ GHC.Types.Char
                            GHC.Show.$fShow(,)3
                            (GHC.Show.showLitString
                               ww1
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.$fShow(,)3
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.showSpace1
                                     (case ww2 of wild1 { Main.Trivial ->
                                      GHC.Base.++
                                        @ GHC.Types.Char
                                        Main.$fShowFour3
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.showSpace1
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.$fShow(,)3
                                              (GHC.Show.showLitString
                                                 ww3
                                                 Main.$fShowFour8))) })))))) })) -}
87b9444b85027383089f2f4260d96715
  $w$s$cshow1 ::
    Main.Trivial -> [GHC.Types.Char] -> Main.Trivial -> GHC.Base.String
  {- Arity: 3, Strictness: <L,1*H><L,1*U><L,1*H>, Inline: [0],
     Unfolding: (\ (ww :: Main.Trivial)
                   (ww1 :: [GHC.Types.Char])
                   (ww2 :: Main.Trivial) ->
                 GHC.CString.unpackAppendCString#
                   Main.$fShowThree2
                   (case ww of wild { Main.Trivial ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      Main.$fShowFour3
                      (GHC.Types.:
                         @ GHC.Types.Char
                         GHC.Show.showSpace1
                         (GHC.Types.:
                            @ GHC.Types.Char
                            GHC.Show.$fShow(,)3
                            (GHC.Show.showLitString
                               ww1
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.$fShow(,)3
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.showSpace1
                                     (case ww2 of wild1 { Main.Trivial ->
                                      Main.$fShowFour3 })))))) })) -}
ccd58b88b6f7a8d5eb84f31416b8891f
  $w$s$cshow2 :: Main.Trivial -> [GHC.Types.Char] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*H><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Main.Trivial) (ww1 :: [GHC.Types.Char]) ->
                 GHC.CString.unpackAppendCString#
                   Main.$fShowTwo2
                   (case ww of wild { Main.Trivial ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      Main.$fShowFour3
                      (GHC.Types.:
                         @ GHC.Types.Char
                         GHC.Show.showSpace1
                         (GHC.Types.:
                            @ GHC.Types.Char
                            GHC.Show.$fShow(,)3
                            (GHC.Show.showLitString ww1 Main.$fShowFour8))) })) -}
289ac6bd99c096a69361f94e345d0d29
  $w$s$cshowsPrec ::
    GHC.Prim.Int#
    -> Main.Trivial
    -> [GHC.Types.Char]
    -> Main.Trivial
    -> [GHC.Types.Char]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 6, Strictness: <S,U><L,1*H><L,1*U><L,1*H><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: Main.Trivial)
                   (ww2 :: [GHC.Types.Char])
                   (ww3 :: Main.Trivial)
                   (ww4 :: [GHC.Types.Char])
                   (w :: GHC.Base.String) ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     GHC.CString.unpackAppendCString#
                       Main.$fShowFour6
                       (case ww1 of wild { Main.Trivial ->
                        GHC.Base.++
                          @ GHC.Types.Char
                          Main.$fShowFour3
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.$fShow(,)3
                                (GHC.Show.showLitString
                                   ww2
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)3
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.showSpace1
                                         (case ww3 of wild1 { Main.Trivial ->
                                          GHC.Base.++
                                            @ GHC.Types.Char
                                            Main.$fShowFour3
                                            (GHC.Types.:
                                               @ GHC.Types.Char
                                               GHC.Show.showSpace1
                                               (GHC.Types.:
                                                  @ GHC.Types.Char
                                                  GHC.Show.$fShow(,)3
                                                  (GHC.Show.showLitString
                                                     ww4
                                                     (GHC.Types.:
                                                        @ GHC.Types.Char
                                                        GHC.Show.$fShow(,)3
                                                        x)))) })))))) })
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT -> p w
                   1#
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w)) }) -}
147471c9f57eed22cd4e53cf0fafdf8f
  $w$s$cshowsPrec1 ::
    GHC.Prim.Int#
    -> Main.Identity [GHC.Types.Char]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Main.Identity [GHC.Types.Char])
                   (w1 :: GHC.Base.String) ->
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Main.$fShowIdentity2
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.$fShow(,)3
                           (GHC.Show.showLitString
                              w `cast` (Main.N:Identity[0] <[GHC.Types.Char]>_R)
                              (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 w1)))
                   1#
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Main.$fShowIdentity2
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.$fShow(,)3
                              (GHC.Show.showLitString
                                 w `cast` (Main.N:Identity[0] <[GHC.Types.Char]>_R)
                                 (GHC.Types.:
                                    @ GHC.Types.Char
                                    GHC.Show.$fShow(,)3
                                    (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w1))))) }) -}
ee1e7dd5f7a8c90f067c5bcd5976beb3
  $w$s$cshowsPrec2 ::
    GHC.Prim.Int#
    -> Main.Or [GHC.Types.Char] Main.Trivial
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Main.Or [GHC.Types.Char] Main.Trivial)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Main.Fst b1
                   -> case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Main.$fShowOr3
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.$fShow(,)3
                                (GHC.Show.showLitString
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 w1)))
                        1#
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Main.$fShowOr3
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.$fShow(,)3
                                   (GHC.Show.showLitString
                                      b1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.$fShow(,)3
                                         (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w1))))) }
                   Main.Snd b1
                   -> case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Main.$fShowOr1
                             (case b1 of wild1 { Main.Trivial ->
                              GHC.Base.++ @ GHC.Types.Char Main.$fShowFour3 w1 })
                        1#
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Main.$fShowOr1
                                (case b1 of wild1 { Main.Trivial ->
                                 GHC.Base.++
                                   @ GHC.Types.Char
                                   Main.$fShowFour3
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w1) })) } }) -}
7eecb844b415ff1d0ce1c9c67ffc669e
  $w$s$cshowsPrec3 ::
    GHC.Prim.Int#
    -> Main.Trivial
    -> [GHC.Types.Char]
    -> Main.Trivial
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5, Strictness: <S,U><L,1*H><L,1*U><L,1*H><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: Main.Trivial)
                   (ww2 :: [GHC.Types.Char])
                   (ww3 :: Main.Trivial)
                   (w :: GHC.Base.String) ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     GHC.CString.unpackAppendCString#
                       Main.$fShowThree2
                       (case ww1 of wild { Main.Trivial ->
                        GHC.Base.++
                          @ GHC.Types.Char
                          Main.$fShowFour3
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.$fShow(,)3
                                (GHC.Show.showLitString
                                   ww2
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)3
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.showSpace1
                                         (case ww3 of wild1 { Main.Trivial ->
                                          GHC.Base.++ @ GHC.Types.Char Main.$fShowFour3 x })))))) })
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT -> p w
                   1#
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w)) }) -}
e8aa5d75f31200c8796014c19557aa04
  $w$s$cshowsPrec4 ::
    GHC.Prim.Int#
    -> Main.Trivial
    -> [GHC.Types.Char]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <S,U><L,1*H><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: Main.Trivial)
                   (ww2 :: [GHC.Types.Char])
                   (w :: GHC.Base.String) ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     GHC.CString.unpackAppendCString#
                       Main.$fShowTwo2
                       (case ww1 of wild { Main.Trivial ->
                        GHC.Base.++
                          @ GHC.Types.Char
                          Main.$fShowFour3
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.showSpace1
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.$fShow(,)3
                                (GHC.Show.showLitString
                                   ww2
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)3 x)))) })
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT -> p w
                   1#
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w)) }) -}
f26f09a4a97c639091da81dbfea4631f
  $wlvl ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Main.Identity [GHC.Types.Char]
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,1*U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: GHC.Prim.Int#) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 case ww8 of ww5 { System.Random.TF.Gen.TFGen ww6 ww10 ww11 ww12 ww13 ww14 ->
                 (Test.QuickCheck.Gen.$wlistOf
                    @ GHC.Types.Char
                    Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
                    ww6
                    ww10
                    ww11
                    ww12
                    ww4)
                   `cast`
                 (Sym (Main.N:Identity[0] <[GHC.Types.Char]>_R)) } }) -}
f81c90c9fc05e6c9348caba94b8766c2
  newtype BoolConj = BoolConj GHC.Types.Bool
5416b7f469160006836cbfdf9823b262
  type BoolConjAssoc =
    Main.BoolConj -> Main.BoolConj -> Main.BoolConj -> GHC.Types.Bool
d4080385790f1b1c227a648ea8e737f2
  newtype BoolDisj = BoolDisj GHC.Types.Bool
d7a638b5aaaef9749e3c4e312e7f3c4e
  type BoolDisjAssoc =
    Main.BoolDisj -> Main.BoolDisj -> Main.BoolDisj -> GHC.Types.Bool
bbe5f09bbf3262cb0ffd25ca31cd894e
  newtype Combine a b = Combine {unCombine :: a -> b}
71ca1b5b4596959890806ef0546c868c
  data Four a b c d = Four a b c d
0fb3a887b296a2e583337afb4dfce110
  type FourAssoc a b c d =
    Main.Four a b c d
    -> Main.Four a b c d -> Main.Four a b c d -> GHC.Types.Bool
147471c9f57eed22cd4e53cf0fafdf8f
  newtype Identity a = Identity a
471e28aa236088e7026a4e1963a1d307
  type IdentityAssoc a =
    Main.Identity a
    -> Main.Identity a -> Main.Identity a -> GHC.Types.Bool
ee1e7dd5f7a8c90f067c5bcd5976beb3
  data Or a b = Fst a | Snd b
53800a6b695d29e36de887279a5fed23
  type OrAssoc a b =
    Main.Or a b -> Main.Or a b -> Main.Or a b -> GHC.Types.Bool
8be194816a28d8986f52eec848797f66
  data Three a b c = Three a b c
4230bcfdb49806ee5b16df1f858f86ec
  type ThreeAssoc a b c =
    Main.Three a b c
    -> Main.Three a b c -> Main.Three a b c -> GHC.Types.Bool
5aae7b9ec6f44b53867d29b495a2b37f
  type TrivAssoc =
    Main.Trivial -> Main.Trivial -> Main.Trivial -> GHC.Types.Bool
45254d41351bf1a0f3b9fd85ef078bac
  data Trivial = Trivial
6915335e4f938e3f9ae253446cb392f1
  data Two a b = Two a b
edf30514f0d29e51b61eb5221e38ff46
  type TwoAssoc a b =
    Main.Two a b -> Main.Two a b -> Main.Two a b -> GHC.Types.Bool
b4f9ae97a091b232a88173a93240314d
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
529073e95d7e97cca9b9c5c633464b51
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U> -}
2ae627898cff160a4ab35ad5461925fa
  main2 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
bbe5f09bbf3262cb0ffd25ca31cd894e
  unCombine :: Main.Combine a b -> a -> b
  RecSel Left Main.Combine
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.unCombine1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Main.Combine a b>_R ->_R Main.N:Combine[0] <a>_N <b>_N) -}
bbe5f09bbf3262cb0ffd25ca31cd894e
  unCombine1 :: Main.Combine a b -> Main.Combine a b
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a @ b (ds :: Main.Combine a b) -> ds) -}
instance [safe] Test.QuickCheck.Arbitrary.Arbitrary [Main.BoolConj]
  = Main.$fArbitraryBoolConj
instance [safe] Test.QuickCheck.Arbitrary.Arbitrary [Main.BoolDisj]
  = Main.$fArbitraryBoolDisj
instance [safe] Test.QuickCheck.Arbitrary.Arbitrary [Main.Four]
  = Main.$fArbitraryFour
instance [safe] Test.QuickCheck.Arbitrary.Arbitrary [Main.Identity]
  = Main.$fArbitraryIdentity
instance [safe] Test.QuickCheck.Arbitrary.Arbitrary [Main.Or]
  = Main.$fArbitraryOr
instance [safe] Test.QuickCheck.Arbitrary.Arbitrary [Main.Three]
  = Main.$fArbitraryThree
instance [safe] Test.QuickCheck.Arbitrary.Arbitrary [Main.Trivial]
  = Main.$fArbitraryTrivial
instance [safe] Test.QuickCheck.Arbitrary.Arbitrary [Main.Two]
  = Main.$fArbitraryTwo
instance [safe] GHC.Classes.Eq [Main.BoolConj] = Main.$fEqBoolConj
instance [safe] GHC.Classes.Eq [Main.BoolDisj] = Main.$fEqBoolDisj
instance [safe] GHC.Classes.Eq [Main.Four] = Main.$fEqFour
instance [safe] GHC.Classes.Eq [Main.Identity] = Main.$fEqIdentity
instance [safe] GHC.Classes.Eq [Main.Or] = Main.$fEqOr
instance [safe] GHC.Classes.Eq [Main.Three] = Main.$fEqThree
instance [safe] GHC.Classes.Eq [Main.Trivial] = Main.$fEqTrivial
instance [safe] GHC.Classes.Eq [Main.Two] = Main.$fEqTwo
instance [safe] GHC.Base.Semigroup [Main.BoolConj]
  = Main.$fSemigroupBoolConj
instance [safe] GHC.Base.Semigroup [Main.BoolDisj]
  = Main.$fSemigroupBoolDisj
instance [safe] GHC.Base.Semigroup [Main.Combine]
  = Main.$fSemigroupCombine
instance [safe] GHC.Base.Semigroup [Main.Four]
  = Main.$fSemigroupFour
instance [safe] GHC.Base.Semigroup [Main.Identity]
  = Main.$fSemigroupIdentity
instance [safe] GHC.Base.Semigroup [Main.Or] = Main.$fSemigroupOr
instance [safe] GHC.Base.Semigroup [Main.Three]
  = Main.$fSemigroupThree
instance [safe] GHC.Base.Semigroup [Main.Trivial]
  = Main.$fSemigroupTrivial
instance [safe] GHC.Base.Semigroup [Main.Two] = Main.$fSemigroupTwo
instance [safe] GHC.Show.Show [Main.BoolConj] = Main.$fShowBoolConj
instance [safe] GHC.Show.Show [Main.BoolDisj] = Main.$fShowBoolDisj
instance [safe] GHC.Show.Show [Main.Four] = Main.$fShowFour
instance [safe] GHC.Show.Show [Main.Identity] = Main.$fShowIdentity
instance [safe] GHC.Show.Show [Main.Or] = Main.$fShowOr
instance [safe] GHC.Show.Show [Main.Three] = Main.$fShowThree
instance [safe] GHC.Show.Show [Main.Trivial] = Main.$fShowTrivial
instance [safe] GHC.Show.Show [Main.Two] = Main.$fShowTwo
"SPEC $carbitrary @ Trivial @ [Char]" forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                               [GHC.Types.Char])
                                             ($dArbitrary1 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                Main.Trivial)
  Main.$fArbitraryTwo1 @ Main.Trivial
                       @ [GHC.Types.Char]
                       $dArbitrary1
                       $dArbitrary
  = Main.$fArbitraryTwo_$s$carbitrary
"SPEC $carbitrary @ Trivial @ [Char] @ Trivial" forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                         Main.Trivial)
                                                       ($dArbitrary1 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                          [GHC.Types.Char])
                                                       ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                          Main.Trivial)
  Main.$fArbitraryThree1 @ Main.Trivial
                         @ [GHC.Types.Char]
                         @ Main.Trivial
                         $dArbitrary2
                         $dArbitrary1
                         $dArbitrary
  = Main.$fArbitraryThree_$s$carbitrary
"SPEC $carbitrary @ Trivial @ [Char] @ Trivial @ [Char]" forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                  [GHC.Types.Char])
                                                                ($dArbitrary1 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                   Main.Trivial)
                                                                ($dArbitrary2 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                   [GHC.Types.Char])
                                                                ($dArbitrary3 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                                   Main.Trivial)
  Main.$fArbitraryFour1 @ Main.Trivial
                        @ [GHC.Types.Char]
                        @ Main.Trivial
                        @ [GHC.Types.Char]
                        $dArbitrary3
                        $dArbitrary2
                        $dArbitrary1
                        $dArbitrary
  = Main.$fArbitraryFour_$s$carbitrary
"SPEC $carbitrary @ [Char] @ Trivial" forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                               Main.Trivial)
                                             ($dArbitrary1 :: Test.QuickCheck.Arbitrary.Arbitrary
                                                                [GHC.Types.Char])
  Main.$fArbitraryOr1 @ [GHC.Types.Char]
                      @ Main.Trivial
                      $dArbitrary1
                      $dArbitrary
  = Main.$fArbitraryOr_$s$carbitrary
"SPEC $cshow @ Trivial @ [Char]" forall ($dShow :: GHC.Show.Show
                                                     [GHC.Types.Char])
                                        ($dShow1 :: GHC.Show.Show Main.Trivial)
  Main.$fShowTwo_$cshow @ Main.Trivial
                        @ [GHC.Types.Char]
                        $dShow1
                        $dShow
  = Main.$fShowTwo_$s$cshow
"SPEC $cshow @ Trivial @ [Char] @ Trivial" forall ($dShow :: GHC.Show.Show
                                                               Main.Trivial)
                                                  ($dShow1 :: GHC.Show.Show [GHC.Types.Char])
                                                  ($dShow2 :: GHC.Show.Show Main.Trivial)
  Main.$fShowThree_$cshow @ Main.Trivial
                          @ [GHC.Types.Char]
                          @ Main.Trivial
                          $dShow2
                          $dShow1
                          $dShow
  = Main.$fShowThree_$s$cshow
"SPEC $cshow @ Trivial @ [Char] @ Trivial @ [Char]" forall ($dShow :: GHC.Show.Show
                                                                        [GHC.Types.Char])
                                                           ($dShow1 :: GHC.Show.Show Main.Trivial)
                                                           ($dShow2 :: GHC.Show.Show
                                                                         [GHC.Types.Char])
                                                           ($dShow3 :: GHC.Show.Show Main.Trivial)
  Main.$fShowFour_$cshow @ Main.Trivial
                         @ [GHC.Types.Char]
                         @ Main.Trivial
                         @ [GHC.Types.Char]
                         $dShow3
                         $dShow2
                         $dShow1
                         $dShow
  = Main.$fShowFour_$s$cshow
"SPEC $cshow @ [Char]" forall ($dShow :: GHC.Show.Show
                                           [GHC.Types.Char])
  Main.$fShowIdentity_$cshow @ [GHC.Types.Char] $dShow
  = Main.$fShowIdentity_$s$cshow
"SPEC $cshow @ [Char] @ Trivial" forall ($dShow :: GHC.Show.Show
                                                     Main.Trivial)
                                        ($dShow1 :: GHC.Show.Show [GHC.Types.Char])
  Main.$fShowOr_$cshow @ [GHC.Types.Char]
                       @ Main.Trivial
                       $dShow1
                       $dShow
  = Main.$fShowOr_$s$cshow
"SPEC $cshowList @ Trivial @ [Char]" forall ($dShow :: GHC.Show.Show
                                                         [GHC.Types.Char])
                                            ($dShow1 :: GHC.Show.Show Main.Trivial)
  Main.$fShowTwo_$cshowList @ Main.Trivial
                            @ [GHC.Types.Char]
                            $dShow1
                            $dShow
  = Main.$fShowTwo_$s$cshowList
"SPEC $cshowList @ Trivial @ [Char] @ Trivial" forall ($dShow :: GHC.Show.Show
                                                                   Main.Trivial)
                                                      ($dShow1 :: GHC.Show.Show [GHC.Types.Char])
                                                      ($dShow2 :: GHC.Show.Show Main.Trivial)
  Main.$fShowThree_$cshowList @ Main.Trivial
                              @ [GHC.Types.Char]
                              @ Main.Trivial
                              $dShow2
                              $dShow1
                              $dShow
  = Main.$fShowThree_$s$cshowList
"SPEC $cshowList @ Trivial @ [Char] @ Trivial @ [Char]" forall ($dShow :: GHC.Show.Show
                                                                            [GHC.Types.Char])
                                                               ($dShow1 :: GHC.Show.Show
                                                                             Main.Trivial)
                                                               ($dShow2 :: GHC.Show.Show
                                                                             [GHC.Types.Char])
                                                               ($dShow3 :: GHC.Show.Show
                                                                             Main.Trivial)
  Main.$fShowFour_$cshowList @ Main.Trivial
                             @ [GHC.Types.Char]
                             @ Main.Trivial
                             @ [GHC.Types.Char]
                             $dShow3
                             $dShow2
                             $dShow1
                             $dShow
  = Main.$fShowFour_$s$cshowList
"SPEC $cshowList @ [Char]" forall ($dShow :: GHC.Show.Show
                                               [GHC.Types.Char])
  Main.$fShowIdentity_$cshowList @ [GHC.Types.Char] $dShow
  = Main.$fShowIdentity_$s$cshowList
"SPEC $cshowList @ [Char] @ Trivial" forall ($dShow :: GHC.Show.Show
                                                         Main.Trivial)
                                            ($dShow1 :: GHC.Show.Show [GHC.Types.Char])
  Main.$fShowOr_$cshowList @ [GHC.Types.Char]
                           @ Main.Trivial
                           $dShow1
                           $dShow
  = Main.$fShowOr_$s$cshowList
"SPEC $cshowsPrec @ Trivial @ [Char]" forall ($dShow :: GHC.Show.Show
                                                          [GHC.Types.Char])
                                             ($dShow1 :: GHC.Show.Show Main.Trivial)
  Main.$fShowTwo_$cshowsPrec @ Main.Trivial
                             @ [GHC.Types.Char]
                             $dShow1
                             $dShow
  = Main.$fShowTwo_$s$cshowsPrec
"SPEC $cshowsPrec @ Trivial @ [Char] @ Trivial" forall ($dShow :: GHC.Show.Show
                                                                    Main.Trivial)
                                                       ($dShow1 :: GHC.Show.Show [GHC.Types.Char])
                                                       ($dShow2 :: GHC.Show.Show Main.Trivial)
  Main.$fShowThree_$cshowsPrec @ Main.Trivial
                               @ [GHC.Types.Char]
                               @ Main.Trivial
                               $dShow2
                               $dShow1
                               $dShow
  = Main.$fShowThree_$s$cshowsPrec
"SPEC $cshowsPrec @ Trivial @ [Char] @ Trivial @ [Char]" forall ($dShow :: GHC.Show.Show
                                                                             [GHC.Types.Char])
                                                                ($dShow1 :: GHC.Show.Show
                                                                              Main.Trivial)
                                                                ($dShow2 :: GHC.Show.Show
                                                                              [GHC.Types.Char])
                                                                ($dShow3 :: GHC.Show.Show
                                                                              Main.Trivial)
  Main.$fShowFour_$cshowsPrec @ Main.Trivial
                              @ [GHC.Types.Char]
                              @ Main.Trivial
                              @ [GHC.Types.Char]
                              $dShow3
                              $dShow2
                              $dShow1
                              $dShow
  = Main.$fShowFour_$s$cshowsPrec
"SPEC $cshowsPrec @ [Char]" forall ($dShow :: GHC.Show.Show
                                                [GHC.Types.Char])
  Main.$fShowIdentity_$cshowsPrec @ [GHC.Types.Char] $dShow
  = Main.$fShowIdentity_$s$cshowsPrec
"SPEC $cshowsPrec @ [Char] @ Trivial" forall ($dShow :: GHC.Show.Show
                                                          Main.Trivial)
                                             ($dShow1 :: GHC.Show.Show [GHC.Types.Char])
  Main.$fShowOr_$cshowsPrec @ [GHC.Types.Char]
                            @ Main.Trivial
                            $dShow1
                            $dShow
  = Main.$fShowOr_$s$cshowsPrec
"SPEC $fShowFour @ Trivial @ [Char] @ Trivial @ [Char]" forall ($dShow :: GHC.Show.Show
                                                                            [GHC.Types.Char])
                                                               ($dShow1 :: GHC.Show.Show
                                                                             Main.Trivial)
                                                               ($dShow2 :: GHC.Show.Show
                                                                             [GHC.Types.Char])
                                                               ($dShow3 :: GHC.Show.Show
                                                                             Main.Trivial)
  Main.$fShowFour @ Main.Trivial
                  @ [GHC.Types.Char]
                  @ Main.Trivial
                  @ [GHC.Types.Char]
                  $dShow3
                  $dShow2
                  $dShow1
                  $dShow
  = Main.$fShowFour_$s$fShowFour
"SPEC $fShowIdentity @ [Char]" forall ($dShow :: GHC.Show.Show
                                                   [GHC.Types.Char])
  Main.$fShowIdentity @ [GHC.Types.Char] $dShow
  = Main.$fShowIdentity_$s$fShowIdentity
"SPEC $fShowOr @ [Char] @ Trivial" forall ($dShow :: GHC.Show.Show
                                                       Main.Trivial)
                                          ($dShow1 :: GHC.Show.Show [GHC.Types.Char])
  Main.$fShowOr @ [GHC.Types.Char] @ Main.Trivial $dShow1 $dShow
  = Main.$fShowOr_$s$fShowOr
"SPEC $fShowThree @ Trivial @ [Char] @ Trivial" forall ($dShow :: GHC.Show.Show
                                                                    Main.Trivial)
                                                       ($dShow1 :: GHC.Show.Show [GHC.Types.Char])
                                                       ($dShow2 :: GHC.Show.Show Main.Trivial)
  Main.$fShowThree @ Main.Trivial
                   @ [GHC.Types.Char]
                   @ Main.Trivial
                   $dShow2
                   $dShow1
                   $dShow
  = Main.$fShowThree_$s$fShowThree
"SPEC $fShowTwo @ Trivial @ [Char]" forall ($dShow :: GHC.Show.Show
                                                        [GHC.Types.Char])
                                           ($dShow1 :: GHC.Show.Show Main.Trivial)
  Main.$fShowTwo @ Main.Trivial @ [GHC.Types.Char] $dShow1 $dShow
  = Main.$fShowTwo_$s$fShowTwo
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

