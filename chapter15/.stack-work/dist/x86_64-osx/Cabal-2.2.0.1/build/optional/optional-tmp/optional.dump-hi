
==================== FINAL INTERFACE ====================
2018-09-02 17:26:39.785985 UTC

interface main:Main 8043
  interface hash: eb889d6b3d48c81ca9dc08ef6a2b1bc3
  ABI hash: 874ec90b7db605990d46047f9971e2f4
  export-list hash: 1ecae6be2ced624a738cee991e51dfac
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 51fe589c5bf186bac449a282a0941ab7
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.main
module dependencies:
package dependencies: QuickCheck-2.11.3 array-0.5.2.0
                      base-4.11.1.0* containers-0.5.11.0 deepseq-1.4.3.0
                      ghc-boot-th-8.4.3 ghc-prim-0.5.2.0 integer-gmp-1.0.2.0
                      pretty-1.1.3.6 primitive-0.6.3.0 random-1.1
                      template-haskell-2.13.0.0 tf-random-0.5 time-1.8.0.2
                      transformers-0.5.5.0
orphans: transformers-0.5.5.0:Control.Monad.Trans.Error
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.11.1.0:GHC.Float
         base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         containers-0.5.11.0:Data.IntMap.Internal
                         containers-0.5.11.0:Data.IntSet.Internal
                         containers-0.5.11.0:Data.Map.Internal
                         containers-0.5.11.0:Data.Sequence.Internal
                         containers-0.5.11.0:Data.Set.Internal
                         ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
import  -/  QuickCheck-2.11.3:Test.QuickCheck 8597fb70e0afba5fb9d4ded03a4b1b62
import  -/  QuickCheck-2.11.3:Test.QuickCheck.Arbitrary 4df33de46388caa5cd1ba81ee16f6b92
import  -/  QuickCheck-2.11.3:Test.QuickCheck.Gen c4ba69576c6fa40fcf812b985e6beea7
import  -/  QuickCheck-2.11.3:Test.QuickCheck.Test 4bcdfba8853ed701d2281003a6c74081
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  ghc-prim-0.5.2.0:GHC.Types d9b3023de7feae4a5308d643da5543f7
f3b0b996ca39feee94a5d06bfe75c7be
  $fArbitraryFirst' ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Arbitrary.Arbitrary (Main.First' a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: Test.QuickCheck.Arbitrary.Arbitrary a).
                  @ (Main.First' a)
                  (Main.$fArbitraryFirst'1 @ a v)
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] <Main.First' a>_R))
                  (\ (ds :: Main.First' a) -> GHC.Types.[] @ (Main.First' a)) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fArbitraryFirst'1 ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Main.First' a
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$carbitrary @ a w ww1 ww2 ww3 ww4 w2 }) -}
e8a181f568268faf283f8db4df7e06a5
  $fArbitraryFirst'2 ::
    [(GHC.Types.Int,
      Test.QuickCheck.Gen.Gen (Main.First' [GHC.Types.Char]))]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Types.Int,
                      Test.QuickCheck.Gen.Gen (Main.First' [GHC.Types.Char]))
                   Main.$fArbitraryFirst'3
                   (GHC.Types.[]
                      @ (GHC.Types.Int,
                         Test.QuickCheck.Gen.Gen (Main.First' [GHC.Types.Char])))) -}
cf50611dc0cad23be8211d3e4a12cc24
  $fArbitraryFirst'3 ::
    (GHC.Types.Int,
     Test.QuickCheck.Gen.Gen (Main.First' [GHC.Types.Char]))
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Main.$fArbitraryFirst'5,
                  Main.$fArbitraryFirst'4
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0]
                            (Main.N:First'[0] <[GHC.Types.Char]>_N))))) -}
2c1a5cf9a2cbcdf5b757f515494c16fa
  $fArbitraryFirst'4 ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> Main.Optional [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: (\ (ds :: Test.QuickCheck.Random.QCGen)
                   (ds1 :: GHC.Types.Int) ->
                 Main.Nada @ [GHC.Types.Char]) -}
03f1521202b3581f8fc786225baa2db8
  $fArbitraryFirst'5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fArbitraryFirst'6 ::
    [(GHC.Types.Int, Test.QuickCheck.Gen.Gen (Main.First' a))]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (\ @ a ->
                 GHC.Types.:
                   @ (GHC.Types.Int, Test.QuickCheck.Gen.Gen (Main.First' a))
                   (Main.$fArbitraryFirst'7 @ a)
                   (GHC.Types.[]
                      @ (GHC.Types.Int, Test.QuickCheck.Gen.Gen (Main.First' a)))) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fArbitraryFirst'7 ::
    (GHC.Types.Int, Test.QuickCheck.Gen.Gen (Main.First' a))
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ a ->
                 (Main.$fArbitraryFirst'5,
                  (Main.$fArbitraryFirst'8 @ a)
                    `cast`
                  (Sym (Test.QuickCheck.Gen.N:Gen[0] (Main.N:First'[0] <a>_N))))) -}
6dbc3784c843ad8d911c67b72d27aaf4
  $fArbitraryFirst'8 ::
    Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> Main.Optional a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: (\ @ a
                   (ds :: Test.QuickCheck.Random.QCGen)
                   (ds1 :: GHC.Types.Int) ->
                 Main.Nada @ a) -}
f143e45a0dac8d5f5f969505b8d70d3d
  $fArbitraryFirst'_$s$carbitrary ::
    Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int -> Main.First' [GHC.Types.Char]
  {- Arity: 2, Strictness: <S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U(U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Test.QuickCheck.Random.QCGen) (w1 :: GHC.Types.Int) ->
                 case w `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$s$carbitrary ww1 ww2 ww3 ww4 w1 }) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fEqFirst' :: GHC.Classes.Eq a => GHC.Classes.Eq (Main.First' a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (Main.First' a)
                  (Main.$fEqFirst'_$c== @ a v)
                    `cast`
                  (Sym (Main.N:First'[0]) <a>_N
                   ->_R Sym (Main.N:First'[0]) <a>_N
                   ->_R <GHC.Types.Bool>_R)
                  (Main.$fEqFirst'_$c/= @ a v)
                    `cast`
                  (Sym (Main.N:First'[0]) <a>_N
                   ->_R Sym (Main.N:First'[0]) <a>_N
                   ->_R <GHC.Types.Bool>_R) -}
63e6810e31345ff3e2b32a03691d84e2
  $fEqFirst'_$c/= ::
    GHC.Classes.Eq a =>
    Main.Optional a -> Main.Optional a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: Main.Optional a)
                   (y :: Main.Optional a) ->
                 case x of wild {
                   Main.Nada
                   -> case y of wild1 {
                        Main.Nada -> GHC.Types.False Main.Only ipv -> GHC.Types.True }
                   Main.Only a1
                   -> case y of wild1 {
                        Main.Nada -> GHC.Types.True
                        Main.Only b1
                        -> case GHC.Classes.== @ a $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
63e6810e31345ff3e2b32a03691d84e2
  $fEqFirst'_$c== ::
    GHC.Classes.Eq a =>
    Main.Optional a -> Main.Optional a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: Main.Optional a)
                   (ds1 :: Main.Optional a) ->
                 case ds of wild {
                   Main.Nada
                   -> case ds1 of wild1 {
                        Main.Nada -> GHC.Types.True Main.Only ipv -> GHC.Types.False }
                   Main.Only a1
                   -> case ds1 of wild1 {
                        Main.Nada -> GHC.Types.False
                        Main.Only b1 -> GHC.Classes.== @ a $dEq a1 b1 } }) -}
63e6810e31345ff3e2b32a03691d84e2
  $fEqOptional ::
    GHC.Classes.Eq a => GHC.Classes.Eq (Main.Optional a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (Main.Optional a)
                  (Main.$fEqFirst'_$c== @ a v)
                  (Main.$fEqFirst'_$c/= @ a v) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fMonoidFirst' :: GHC.Base.Monoid (Main.First' a)
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ a.
                  @ (Main.First' a)
                  (Main.$fSemigroupFirst' @ a)
                  (Main.Nada @ a) `cast` (Sym (Main.N:First'[0]) <a>_N)
                  (Main.$fMonoidFirst'_$c<> @ a)
                  (Main.$fMonoidFirst'_go @ a) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fMonoidFirst'_$c<> ::
    Main.First' a -> Main.First' a -> Main.First' a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (ds :: Main.First' a) (ds1 :: Main.First' a) ->
                 case ds `cast` (Main.N:First'[0] <a>_N) of wild {
                   Main.Nada -> ds1
                   Main.Only x
                   -> (Main.Only @ a x) `cast` (Sym (Main.N:First'[0]) <a>_N) }) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fMonoidFirst'_go :: [Main.First' a] -> Main.First' a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
63e6810e31345ff3e2b32a03691d84e2
  $fMonoidOptional ::
    GHC.Base.Monoid a => GHC.Base.Monoid (Main.Optional a)
  DFunId
  {- Arity: 1, Strictness: <L,U(U(C(C1(U)),A,A),A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Base.Monoid a).
                  @ (Main.Optional a)
                  (Main.$fMonoidOptional_$cp1Monoid @ a v)
                  (Main.Nada @ a)
                  (Main.$fMonoidOptional_$cmappend @ a v)
                  (Main.$fMonoidOptional_$cmconcat @ a v) -}
63e6810e31345ff3e2b32a03691d84e2
  $fMonoidOptional_$cmappend ::
    GHC.Base.Monoid a =>
    Main.Optional a -> Main.Optional a -> Main.Optional a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*U(1*C1(C1(U)),A,A),A,A,A)><S,1*U><S,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (1, False, False)
                (\ @ a ($dMonoid :: GHC.Base.Monoid a) ->
                 let {
                   $dSemigroup :: GHC.Base.Semigroup a
                   = GHC.Base.$p1Monoid @ a $dMonoid
                 } in
                 \ (ds :: Main.Optional a) (ds1 :: Main.Optional a) ->
                 case ds of wild {
                   Main.Nada -> ds1
                   Main.Only x
                   -> case ds1 of wild1 {
                        Main.Nada -> Main.Only @ a x
                        Main.Only y
                        -> Main.Only @ a (GHC.Base.<> @ a $dSemigroup x y) } }) -}
63e6810e31345ff3e2b32a03691d84e2
  $fMonoidOptional_$cmconcat ::
    GHC.Base.Monoid a => [Main.Optional a] -> Main.Optional a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A,A),A,A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dMonoid :: GHC.Base.Monoid a)
                   (eta :: [Main.Optional a]) ->
                 let {
                   $dSemigroup :: GHC.Base.Semigroup a
                   = GHC.Base.$p1Monoid @ a $dMonoid
                 } in
                 letrec {
                   go :: [Main.Optional a] -> Main.Optional a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Main.Optional a]) ->
                     case ds of wild {
                       [] -> Main.Nada @ a
                       : y ys
                       -> case y of wild1 {
                            Main.Nada -> go ys
                            Main.Only x
                            -> case go ys of wild2 {
                                 Main.Nada -> wild1
                                 Main.Only y1
                                 -> Main.Only @ a (GHC.Base.<> @ a $dSemigroup x y1) } } }
                 } in
                 go eta) -}
63e6810e31345ff3e2b32a03691d84e2
  $fMonoidOptional_$cp1Monoid ::
    GHC.Base.Monoid a => GHC.Base.Semigroup (Main.Optional a)
  {- Arity: 1, Strictness: <L,1*U(1*U(C(C1(U)),A,A),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dMonoid :: GHC.Base.Monoid a) ->
                 Main.$fSemigroupOptional @ a (GHC.Base.$p1Monoid @ a $dMonoid)) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fSemigroupFirst' :: GHC.Base.Semigroup (Main.First' a)
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ a.
                  @ (Main.First' a)
                  (Main.$fMonoidFirst'_$c<> @ a)
                  (Main.$fSemigroupFirst'_$csconcat @ a)
                  (Main.$fSemigroupFirst'_$cstimes @ a) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fSemigroupFirst'1 ::
    Main.First' a -> [Main.First' a] -> Main.First' a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fSemigroupFirst'_$csconcat ::
    GHC.Base.NonEmpty (Main.First' a) -> Main.First' a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SS),1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: GHC.Base.NonEmpty (Main.First' a)) ->
                 case ds of wild { GHC.Base.:| a1 as ->
                 Main.$fSemigroupFirst'1 @ a a1 as }) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fSemigroupFirst'_$cstimes ::
    GHC.Real.Integral b => b -> Main.First' a -> Main.First' a
  {- Arity: 1, Strictness: <L,U> -}
63e6810e31345ff3e2b32a03691d84e2
  $fSemigroupOptional ::
    GHC.Base.Semigroup a => GHC.Base.Semigroup (Main.Optional a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Base.Semigroup a).
                  @ (Main.Optional a)
                  (Main.$fSemigroupOptional_$c<> @ a v)
                  (Main.$fSemigroupOptional_$csconcat @ a v)
                  (Main.$fSemigroupOptional_$cstimes @ a v) -}
63e6810e31345ff3e2b32a03691d84e2
  $fSemigroupOptional_$c<> ::
    GHC.Base.Semigroup a =>
    Main.Optional a -> Main.Optional a -> Main.Optional a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dSemigroup :: GHC.Base.Semigroup a)
                   (ds :: Main.Optional a)
                   (ds1 :: Main.Optional a) ->
                 case ds of wild {
                   Main.Nada -> ds1
                   Main.Only x
                   -> case ds1 of wild1 {
                        Main.Nada -> Main.Only @ a x
                        Main.Only y
                        -> Main.Only @ a (GHC.Base.<> @ a $dSemigroup x y) } }) -}
63e6810e31345ff3e2b32a03691d84e2
  $fSemigroupOptional_$csconcat ::
    GHC.Base.Semigroup a =>
    GHC.Base.NonEmpty (Main.Optional a) -> Main.Optional a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><S(SS),1*U(1*U,1*U)>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: GHC.Base.Semigroup a)
                   (w1 :: GHC.Base.NonEmpty (Main.Optional a)) ->
                 case w1 of ww { GHC.Base.:| ww1 ww2 ->
                 Main.$w$csconcat @ a w ww1 ww2 }) -}
63e6810e31345ff3e2b32a03691d84e2
  $fSemigroupOptional_$cstimes ::
    GHC.Base.Semigroup a =>
    forall b.
    GHC.Real.Integral b =>
    b -> Main.Optional a -> Main.Optional a
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><L,U> -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fShowFirst' :: GHC.Show.Show a => GHC.Show.Show (Main.First' a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Main.First' a)
                  (Main.$fShowFirst'_$cshowsPrec @ a v)
                  (Main.$fShowFirst'_$cshow @ a v)
                  (Main.$fShowFirst'_$cshowList @ a v) -}
3b3cf76d83240cdcdad137f3894d7319
  $fShowFirst'1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
6a75ca60f2ad287df9331aae0c1804bd
  $fShowFirst'10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("getFirst' = "#) -}
22a6db11bd0e52f46fb7292366408572
  $fShowFirst'11 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("First' {"#) -}
7052e962080a17d87fea498e5220d354
  $fShowFirst'12 :: Main.First' [GHC.Types.Char] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U><L,U>,
     Unfolding: (\ (w :: Main.First' [GHC.Types.Char])
                   (w1 :: GHC.Base.String) ->
                 Main.$w$s$cshowsPrec 0# w w1) -}
786e7b13e2a03e6e1533a6296eb37826
  $fShowFirst'13 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
4e61517a81def5695429cbafc080670d
  $fShowFirst'14 :: [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 1,
     Unfolding: (GHC.Base.++ @ GHC.Types.Char Main.$fShowFirst'8) -}
811ee4b1c635e7e5b60526132976e250
  $fShowFirst'2 :: [GHC.Types.Char]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.$fShow(,)3
                   Main.$fShowFirst'3) -}
d238ff91d289a3d3d963a7592bfe07c2
  $fShowFirst'3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.$fShowFirst'4) -}
a3fb3eeb98e96b0d8508ffe9561d8360
  $fShowFirst'4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("}"#) -}
fd0bf6d875cc6cd8a5d853c44fca2cc4
  $fShowFirst'5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.$fShowFirst'6) -}
80bd5fca8ca234ea5d233664aa6265a4
  $fShowFirst'6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Only "#) -}
f5ae9034d3579bdc24723a649c7005fd
  $fShowFirst'7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Main.$fShowFirst'8
                   Main.$fShowFirst'3) -}
effcb6e1ff46e7b44107ed7c98984c44
  $fShowFirst'8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.$fShowFirst'9) -}
d4ecab86fe7b3fa92d9790694645d133
  $fShowFirst'9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Nada"#) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fShowFirst'_$cshow ::
    GHC.Show.Show a => Main.First' a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><L,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Main.First' a) ->
                 GHC.CString.unpackAppendCString#
                   Main.$fShowFirst'11
                   (GHC.CString.unpackAppendCString#
                      Main.$fShowFirst'10
                      (case x `cast` (Main.N:First'[0] <a>_N) of wild {
                         Main.Nada -> Main.$fShowFirst'7
                         Main.Only b1
                         -> GHC.Base.++
                              @ GHC.Types.Char
                              Main.$fShowFirst'5
                              (GHC.Show.showsPrec
                                 @ a
                                 $dShow
                                 Main.$fShowFirst'13
                                 b1
                                 Main.$fShowFirst'3) }))) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fShowFirst'_$cshowList ::
    GHC.Show.Show a => [Main.First' a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Main.First' a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.First' a)
                   (Main.$fShowFirst'_$cshowsPrec @ a $dShow Main.$fShowFirst'1)
                   ls
                   s) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fShowFirst'_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Main.First' a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><L,1*U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Main.First' a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Main.$w$cshowsPrec @ a w ww1 w2 }) -}
63e6810e31345ff3e2b32a03691d84e2
  $fShowFirst'_$cshowsPrec1 ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Main.Optional a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (ds1 :: Main.Optional a) ->
                 case ds1 of wild {
                   Main.Nada -> Main.$fShowFirst'14
                   Main.Only b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a $dShow Main.$fShowFirst'13 b1
                      } in
                      case GHC.Prim.>=# x 11# of lwild {
                        DEFAULT
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char Main.$fShowFirst'5 (g x1)
                        1#
                        -> \ (x1 :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Main.$fShowFirst'5
                                (g (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)2
                                      x1))) } } }) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fShowFirst'_$s$cshow ::
    Main.First' [GHC.Types.Char] -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (x :: Main.First' [GHC.Types.Char]) ->
                 GHC.CString.unpackAppendCString#
                   Main.$fShowFirst'11
                   (GHC.CString.unpackAppendCString#
                      Main.$fShowFirst'10
                      (case x `cast` (Main.N:First'[0] <[GHC.Types.Char]>_N) of wild {
                         Main.Nada -> Main.$fShowFirst'7
                         Main.Only b1
                         -> GHC.Base.++
                              @ GHC.Types.Char
                              Main.$fShowFirst'5
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.$fShow(,)3
                                 (GHC.Show.showLitString b1 Main.$fShowFirst'2)) }))) -}
541aa9f08ab6afb17b7b5b72661989ce
  $fShowFirst'_$s$cshowList ::
    [Main.First' [GHC.Types.Char]] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Main.First' [GHC.Types.Char]]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.First' [GHC.Types.Char])
                   Main.$fShowFirst'12
                   ls
                   s) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fShowFirst'_$s$cshowsPrec ::
    GHC.Types.Int -> Main.First' [GHC.Types.Char] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><L,1*U><L,U>, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Main.First' [GHC.Types.Char])
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Main.$w$s$cshowsPrec ww1 w1 w2 }) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $fShowFirst'_$s$fShowFirst' ::
    GHC.Show.Show (Main.First' [GHC.Types.Char])
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Main.First' [GHC.Types.Char])
                  Main.$fShowFirst'_$s$cshowsPrec
                  Main.$fShowFirst'_$s$cshow
                  (\ (ls :: [Main.First' [GHC.Types.Char]]) (s :: GHC.Base.String) ->
                   GHC.Show.showList__
                     @ (Main.First' [GHC.Types.Char])
                     (Main.$fShowFirst'_$s$cshowsPrec Main.$fShowFirst'1)
                     ls
                     s) -}
63e6810e31345ff3e2b32a03691d84e2
  $fShowOptional ::
    GHC.Show.Show a => GHC.Show.Show (Main.Optional a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Main.Optional a)
                  (Main.$fShowFirst'_$cshowsPrec1 @ a v)
                  (Main.$fShowOptional_$cshow @ a v)
                  (Main.$fShowOptional_$cshowList @ a v) -}
63e6810e31345ff3e2b32a03691d84e2
  $fShowOptional_$cshow ::
    GHC.Show.Show a => Main.Optional a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Main.Optional a) ->
                 case x of wild {
                   Main.Nada -> Main.$fShowFirst'8
                   Main.Only b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Main.$fShowFirst'5
                        (GHC.Show.showsPrec
                           @ a
                           $dShow
                           Main.$fShowFirst'13
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
63e6810e31345ff3e2b32a03691d84e2
  $fShowOptional_$cshowList ::
    GHC.Show.Show a => [Main.Optional a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Main.Optional a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Optional a)
                   (Main.$fShowFirst'_$cshowsPrec1 @ a $dShow Main.$fShowFirst'1)
                   ls
                   s) -}
d240515859c1263afb6a6d5ae88243ee
  $s$fTestable(->)3 ::
    (Main.First' GHC.Base.String -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.First' GHC.Base.String -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable w ww1 ww2 ww3 ww4 w2 }) -}
d67a5ec57c0c69a0394b5a068b98df55
  $s$fTestable(->)4 ::
    Main.First' [GHC.Types.Char] -> [Main.First' [GHC.Types.Char]]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Main.First' [GHC.Types.Char]) ->
                 GHC.Types.[] @ (Main.First' [GHC.Types.Char])) -}
49bb6aa6d19f5b6c03e71db935972779
  $s$fTestable(->)6 ::
    (Main.First' GHC.Base.String
     -> Main.First' GHC.Base.String -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Main.First' GHC.Base.String
                         -> Main.First' GHC.Base.String -> GHC.Types.Bool)
                   (w1 :: Test.QuickCheck.Random.QCGen)
                   (w2 :: GHC.Types.Int) ->
                 case w1
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$w$dTestable1 w ww1 ww2 ww3 ww4 w2 }) -}
79811154284579fdf046f31f4eb44437
  $tc'First' :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13895118926596036773##
                   17307412700836312529##
                   Main.$trModule
                   Main.$tc'First'2
                   1#
                   Main.$tc'First'1) -}
affa5aeb0b3ac63e9766a12474637b3f
  $tc'First'1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
fbfc77522a8262e87fcde2aaf6fec6b1
  $tc'First'2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'First'3) -}
a8f30ac903723f87b7e12ae30517d494
  $tc'First'3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'First'"#) -}
5e9c0e79863826f88c3f46a4bb810717
  $tc'Nada :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17499030812836774634##
                   16690056909217107473##
                   Main.$trModule
                   Main.$tc'Nada2
                   1#
                   Main.$tc'Nada1) -}
66057343eccb018ad58e75197bfe2f2a
  $tc'Nada1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
5c844f14d23adb10a86d80732a1398b1
  $tc'Nada2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Nada3) -}
79fbf96086db7dd75cfec6d4e010214b
  $tc'Nada3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Nada"#) -}
b29065c6617104dbb1f9a998a0adee55
  $tc'Only :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9622104875402380031##
                   2466049537395243731##
                   Main.$trModule
                   Main.$tc'Only2
                   1#
                   Main.$tc'Only1) -}
3303a4cbe9480551e35b5b20f0c2ab47
  $tc'Only1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
9af3f336336de1ec4c8c806023a94643
  $tc'Only2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Only3) -}
3438ca5f9cf8a8ea93ef9a02bb099033
  $tc'Only3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Only"#) -}
245da63e6af2d867b8f13b1e60e61ba9
  $tcFirst' :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3912303963076004324##
                   7173229665336643204##
                   Main.$trModule
                   Main.$tcFirst'1
                   0#
                   GHC.Types.krep$*Arr*) -}
5a62b476068015509cd087e04b8ea896
  $tcFirst'1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcFirst'2) -}
37461f885f1c21d6cf4e59bf09c8851f
  $tcFirst'2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("First'"#) -}
ee7c2332c69da5a07884a3cc8d4e0b4d
  $tcOptional :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18181554394217420575##
                   2219304908904406062##
                   Main.$trModule
                   Main.$tcOptional1
                   0#
                   GHC.Types.krep$*Arr*) -}
4ca7b8015d8c1227c214aed1d69dada0
  $tcOptional1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcOptional2) -}
aa3ff72379706bc555ae1b3ba840a697
  $tcOptional2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Optional"#) -}
be86c9d078d3acbf19ba91fe74a24273
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule3 Main.$trModule1) -}
b09d86f2c49dd5176b544d8d13ddb6c5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule2) -}
e5875966b74dad2d29772660b8a75e33
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Main"#) -}
23b03bd7d075a00f5ad1ee10e6add7b8
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule4) -}
d026be77cb9ced20e35a61514e0458aa
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $w$carbitrary ::
    Test.QuickCheck.Arbitrary.Arbitrary a =>
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Main.First' a
  {- Arity: 6,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: Test.QuickCheck.Arbitrary.Arbitrary a)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 let {
                   a1 :: a
                   = (Test.QuickCheck.Arbitrary.arbitrary @ a w)
                       `cast`
                     (Test.QuickCheck.Gen.N:Gen[0] <a>_R)
                       ww8 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                       w1
                 } in
                 (Test.QuickCheck.Gen.frequency
                    @ (Main.First' a)
                    (GHC.Types.:
                       @ (GHC.Types.Int, Test.QuickCheck.Gen.Gen (Main.First' a))
                       (Main.$fArbitraryFirst'5,
                        let {
                          x :: Main.Optional a = Main.Only @ a a1
                        } in
                        (\ (ds :: Test.QuickCheck.Random.QCGen) (ds1 :: GHC.Types.Int) ->
                         x)
                          `cast`
                        (Sym (Test.QuickCheck.Gen.N:Gen[0] (Main.N:First'[0] <a>_N))))
                       (Main.$fArbitraryFirst'6 @ a)))
                   `cast`
                 (Test.QuickCheck.Gen.N:Gen[0] <Main.First' a>_R)
                   ww9 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                   w1 }) -}
63e6810e31345ff3e2b32a03691d84e2
  $w$csconcat ::
    GHC.Base.Semigroup a =>
    Main.Optional a -> [Main.Optional a] -> Main.Optional a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A)><S,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Base.Semigroup a)
                   (ww :: Main.Optional a)
                   (ww1 :: [Main.Optional a]) ->
                 letrec {
                   go :: Main.Optional a -> [Main.Optional a] -> Main.Optional a
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (b :: Main.Optional a) (ds1 :: [Main.Optional a]) ->
                     case ds1 of wild1 {
                       [] -> b
                       : c cs
                       -> case b of wild {
                            Main.Nada -> go c cs
                            Main.Only x
                            -> case go c cs of wild2 {
                                 Main.Nada -> wild
                                 Main.Only y -> Main.Only @ a (GHC.Base.<> @ a w x y) } } }
                 } in
                 go ww ww1) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $w$cshowsPrec ::
    GHC.Show.Show a => GHC.Prim.Int# -> Main.First' a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Main.First' a) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = Main.$fShowFirst'_$cshowsPrec1
                       @ a
                       w
                       Main.$fShowFirst'1
                       w1 `cast` (Main.N:First'[0] <a>_N)
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        Main.$fShowFirst'11
                        (GHC.CString.unpackAppendCString#
                           Main.$fShowFirst'10
                           (f (GHC.CString.unpackAppendCString# Main.$fShowFirst'4 x)))
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Main.$fShowFirst'11
                           (GHC.CString.unpackAppendCString#
                              Main.$fShowFirst'10
                              (f (GHC.CString.unpackAppendCString#
                                    Main.$fShowFirst'4
                                    (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))))) }) -}
6c2958e7a5bbb9c1d3a02688e2eda417
  $w$dTestable ::
    (Main.First' GHC.Base.String -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.First' GHC.Base.String -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ (Main.First' GHC.Base.String)
                   @ GHC.Types.Bool
                   Main.$fShowFirst'_$s$fShowFirst'
                   Test.QuickCheck.Property.$fTestableBool_$cproperty
                     `cast`
                   (Sym (Test.QuickCheck.Property.N:Testable[0] <GHC.Types.Bool>_N))
                   Main.$fArbitraryFirst'_$s$carbitrary
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Main.First' [GHC.Types.Char]>_R))
                   Main.$s$fTestable(->)4
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
c4e568d32c788c3a6000845332cd3d80
  $w$dTestable1 ::
    (Main.First' GHC.Base.String
     -> Main.First' GHC.Base.String -> GHC.Types.Bool)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 6, Strictness: <L,C(U)><S,U><S,U><S,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Main.First' GHC.Base.String
                         -> Main.First' GHC.Base.String -> GHC.Types.Bool)
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ (Main.First' GHC.Base.String)
                   @ (Main.First' GHC.Base.String -> GHC.Types.Bool)
                   Main.$fShowFirst'_$s$fShowFirst'
                   Main.$s$fTestable(->)3
                     `cast`
                   ((<Main.First' GHC.Base.String -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <Main.First'
                                                                                                                                       GHC.Base.String
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Main.$fArbitraryFirst'_$s$carbitrary
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Main.First' [GHC.Types.Char]>_R))
                   Main.$s$fTestable(->)4
                   w
                   ww
                   ww1
                   ww2
                   ww3
                   w1) -}
b95dd0559ebb3eb444d19beff90ea5bf
  $w$s$carbitrary ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Word#
    -> GHC.Prim.Word#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Main.First' [GHC.Types.Char]
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,1*U><L,U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Word#)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: GHC.Prim.Int#)
                   (w :: GHC.Types.Int) ->
                 case System.Random.TF.Gen.$wtfGenSplit
                        ww
                        ww1
                        ww2
                        ww3 of ww7 { (#,#) ww8 ww9 ->
                 let {
                   a :: [GHC.Types.Char]
                   = case ww8 of ww4 { System.Random.TF.Gen.TFGen ww5 ww6 ww10 ww11 ww12 ww13 ->
                     case w of ww14 { GHC.Types.I# ww15 ->
                     Test.QuickCheck.Gen.$wlistOf
                       @ GHC.Types.Char
                       Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
                       ww5
                       ww6
                       ww10
                       ww11
                       ww15 } }
                 } in
                 (Test.QuickCheck.Gen.frequency
                    @ (Main.First' [GHC.Types.Char])
                    (GHC.Types.:
                       @ (GHC.Types.Int,
                          Test.QuickCheck.Gen.Gen (Main.First' [GHC.Types.Char]))
                       (Main.$fArbitraryFirst'5,
                        let {
                          x :: Main.Optional [GHC.Types.Char]
                          = Main.Only @ [GHC.Types.Char] a
                        } in
                        (\ (ds :: Test.QuickCheck.Random.QCGen) (ds1 :: GHC.Types.Int) ->
                         x)
                          `cast`
                        (Sym (Test.QuickCheck.Gen.N:Gen[0]
                                  (Main.N:First'[0] <[GHC.Types.Char]>_N))))
                       Main.$fArbitraryFirst'2))
                   `cast`
                 (Test.QuickCheck.Gen.N:Gen[0] <Main.First' [GHC.Types.Char]>_R)
                   ww9 `cast` (Sym (Test.QuickCheck.Random.N:QCGen[0]))
                   w }) -}
f3b0b996ca39feee94a5d06bfe75c7be
  $w$s$cshowsPrec ::
    GHC.Prim.Int#
    -> Main.First' [GHC.Types.Char]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Main.First' [GHC.Types.Char])
                   (w1 :: GHC.Base.String) ->
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> GHC.CString.unpackAppendCString#
                        Main.$fShowFirst'11
                        (GHC.CString.unpackAppendCString#
                           Main.$fShowFirst'10
                           (case w `cast` (Main.N:First'[0] <[GHC.Types.Char]>_N) of wild {
                              Main.Nada
                              -> GHC.Base.++
                                   @ GHC.Types.Char
                                   Main.$fShowFirst'8
                                   (GHC.CString.unpackAppendCString# Main.$fShowFirst'4 w1)
                              Main.Only b1
                              -> GHC.Base.++
                                   @ GHC.Types.Char
                                   Main.$fShowFirst'5
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)3
                                      (GHC.Show.showLitString
                                         b1
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.$fShow(,)3
                                            (GHC.CString.unpackAppendCString#
                                               Main.$fShowFirst'4
                                               w1)))) }))
                   1#
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           Main.$fShowFirst'11
                           (GHC.CString.unpackAppendCString#
                              Main.$fShowFirst'10
                              (case w `cast` (Main.N:First'[0] <[GHC.Types.Char]>_N) of wild {
                                 Main.Nada
                                 -> GHC.Base.++
                                      @ GHC.Types.Char
                                      Main.$fShowFirst'8
                                      (GHC.CString.unpackAppendCString#
                                         Main.$fShowFirst'4
                                         (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 w1))
                                 Main.Only b1
                                 -> GHC.Base.++
                                      @ GHC.Types.Char
                                      Main.$fShowFirst'5
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.$fShow(,)3
                                         (GHC.Show.showLitString
                                            b1
                                            (GHC.Types.:
                                               @ GHC.Types.Char
                                               GHC.Show.$fShow(,)3
                                               (GHC.CString.unpackAppendCString#
                                                  Main.$fShowFirst'4
                                                  (GHC.Types.:
                                                     @ GHC.Types.Char
                                                     GHC.Show.$fShow(,)2
                                                     w1))))) }))) }) -}
f3b0b996ca39feee94a5d06bfe75c7be
  newtype First' a = First' {getFirst' :: Main.Optional a}
3d1d59836202eeda6b49bd37ce9db99f
  type FirstMappend =
    Main.First' GHC.Base.String
    -> Main.First' GHC.Base.String
    -> Main.First' GHC.Base.String
    -> GHC.Types.Bool
23fb436758796402a8e71e256ee15802
  type FstId = Main.First' GHC.Base.String -> GHC.Types.Bool
63e6810e31345ff3e2b32a03691d84e2
  data Optional a = Nada | Only a
f3b0b996ca39feee94a5d06bfe75c7be
  getFirst' :: Main.First' a -> Main.Optional a
  RecSel Left Main.First'
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.getFirst'1
                  `cast`
                (forall (a :: <*>_N).
                 <Main.First' a>_R ->_R Main.N:First'[0] <a>_N) -}
f3b0b996ca39feee94a5d06bfe75c7be
  getFirst'1 :: Main.First' a -> Main.First' a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (ds :: Main.First' a) -> ds) -}
588640a0296252a5daa60620b14598b8
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
e55d3234f049d42d51bb6fd74844231c
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case Test.QuickCheck.Test.$wquickCheckWithResult
                        @ Main.FirstMappend
                        Main.main4
                          `cast`
                        ((<Main.First' GHC.Base.String
                           -> Main.First' GHC.Base.String
                           -> Main.First' GHC.Base.String
                           -> GHC.Types.Bool>_R
                          ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                        (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                         <Main.First'
                                                                                                                                            GHC.Base.String
                                                                                                                                          -> Main.First'
                                                                                                                                               GHC.Base.String
                                                                                                                                          -> Main.First'
                                                                                                                                               GHC.Base.String
                                                                                                                                          -> GHC.Types.Bool>_N))
                        (GHC.Base.Nothing @ (Test.QuickCheck.Random.QCGen, GHC.Types.Int))
                        Test.QuickCheck.Test.stdArgs2
                        Test.QuickCheck.Test.stdArgs1
                        Test.QuickCheck.Test.stdArgs2
                        GHC.Types.True
                        GHC.Base.maxInt
                        Main.main3
                        s of ds3 { (#,#) ipv ipv1 ->
                 case Test.QuickCheck.Test.$wquickCheckWithResult
                        @ Main.FstId
                        Main.$s$fTestable(->)3
                          `cast`
                        ((<Main.First' GHC.Base.String -> GHC.Types.Bool>_R
                          ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                        (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                         <Main.First'
                                                                                                                                            GHC.Base.String
                                                                                                                                          -> GHC.Types.Bool>_N))
                        (GHC.Base.Nothing @ (Test.QuickCheck.Random.QCGen, GHC.Types.Int))
                        Test.QuickCheck.Test.stdArgs2
                        Test.QuickCheck.Test.stdArgs1
                        Test.QuickCheck.Test.stdArgs2
                        GHC.Types.True
                        GHC.Base.maxInt
                        Main.main2
                        ipv of ds1 { (#,#) ipv2 ipv3 ->
                 case Test.QuickCheck.Test.$wquickCheckWithResult
                        @ Main.FstId
                        Main.$s$fTestable(->)3
                          `cast`
                        ((<Main.First' GHC.Base.String -> GHC.Types.Bool>_R
                          ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                        (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                         <Main.First'
                                                                                                                                            GHC.Base.String
                                                                                                                                          -> GHC.Types.Bool>_N))
                        (GHC.Base.Nothing @ (Test.QuickCheck.Random.QCGen, GHC.Types.Int))
                        Test.QuickCheck.Test.stdArgs2
                        Test.QuickCheck.Test.stdArgs1
                        Test.QuickCheck.Test.stdArgs2
                        GHC.Types.True
                        GHC.Base.maxInt
                        Main.main2
                        ipv2 of ds2 { (#,#) ipv4 ipv5 ->
                 (# ipv4, GHC.Tuple.() #) } } }) -}
05a93b23683a4a2dabe3badc0584ae9e
  main2 :: Main.First' GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (a :: Main.First' GHC.Base.String) ->
                 case a `cast` (Main.N:First'[0] <[GHC.Types.Char]>_N) of wild {
                   Main.Nada -> GHC.Types.True
                   Main.Only a1 -> GHC.Base.eqString a1 a1 }) -}
28bf247af4c94d12f52edcf4e95f8afc
  main3 ::
    Main.First' GHC.Base.String
    -> Main.First' GHC.Base.String
    -> Main.First' GHC.Base.String
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <S,U><L,U><L,U>,
     Unfolding: (\ (a :: Main.First' GHC.Base.String)
                   (b :: Main.First' GHC.Base.String)
                   (c :: Main.First' GHC.Base.String) ->
                 let {
                   $j :: [GHC.Types.Char] -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (a1 :: [GHC.Types.Char])[OneShot] ->
                     case a `cast` (Main.N:First'[0] <[GHC.Types.Char]>_N) of wild {
                       Main.Nada
                       -> case b `cast` (Main.N:First'[0] <[GHC.Types.Char]>_N) of wild1 {
                            Main.Nada
                            -> case c `cast` (Main.N:First'[0] <[GHC.Types.Char]>_N) of wild2 {
                                 Main.Nada -> GHC.Types.False
                                 Main.Only b1 -> GHC.Base.eqString a1 b1 }
                            Main.Only x -> GHC.Base.eqString a1 x }
                       Main.Only x -> GHC.Base.eqString a1 x }
                 } in
                 case a `cast` (Main.N:First'[0] <[GHC.Types.Char]>_N) of wild {
                   Main.Nada
                   -> case b `cast` (Main.N:First'[0] <[GHC.Types.Char]>_N) of wild1 {
                        Main.Nada
                        -> case c `cast` (Main.N:First'[0] <[GHC.Types.Char]>_N) of wild2 {
                             Main.Nada -> GHC.Types.True Main.Only a1 -> $j a1 }
                        Main.Only x -> $j x }
                   Main.Only x -> $j x }) -}
01a65403b64d232bbdde88cbdb7f4d14
  main4 ::
    (Main.First' GHC.Base.String
     -> Main.First' GHC.Base.String
     -> Main.First' GHC.Base.String
     -> GHC.Types.Bool)
    -> Test.QuickCheck.Random.QCGen
    -> GHC.Types.Int
    -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result
  {- Arity: 3,
     Strictness: <L,C(U)><S(SSSSLL),1*U(U,U,U,1*U,A,A)><L,U>,
     Unfolding: (\ (f :: Main.First' GHC.Base.String
                         -> Main.First' GHC.Base.String
                         -> Main.First' GHC.Base.String
                         -> GHC.Types.Bool)[OneShot]
                   (eta :: Test.QuickCheck.Random.QCGen)
                   (eta1 :: GHC.Types.Int)[OneShot] ->
                 case eta
                        `cast`
                      (Test.QuickCheck.Random.N:QCGen[0]) of ww { System.Random.TF.Gen.TFGen ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Test.QuickCheck.Property.$wforAllShrink
                   @ (Main.First' GHC.Base.String)
                   @ (Main.First' GHC.Base.String
                      -> Main.First' GHC.Base.String -> GHC.Types.Bool)
                   Main.$fShowFirst'_$s$fShowFirst'
                   Main.$s$fTestable(->)6
                     `cast`
                   ((<Main.First' GHC.Base.String
                      -> Main.First' GHC.Base.String -> GHC.Types.Bool>_R
                     ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                   (Test.QuickCheck.Property.N:Prop[0])) ; Sym (Test.QuickCheck.Property.N:Property[0])) ; Sym (Test.QuickCheck.Property.N:Testable[0]
                                                                                                                                    <Main.First'
                                                                                                                                       GHC.Base.String
                                                                                                                                     -> Main.First'
                                                                                                                                          GHC.Base.String
                                                                                                                                     -> GHC.Types.Bool>_N))
                   Main.$fArbitraryFirst'_$s$carbitrary
                     `cast`
                   (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Main.First' [GHC.Types.Char]>_R))
                   Main.$s$fTestable(->)4
                   f
                   ww1
                   ww2
                   ww3
                   ww4
                   eta1 }) -}
6661a3b78ac4319252be233cd9c673ba
  main5 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
instance [safe] Test.QuickCheck.Arbitrary.Arbitrary [Main.First']
  = Main.$fArbitraryFirst'
instance [safe] GHC.Classes.Eq [Main.First'] = Main.$fEqFirst'
instance [safe] GHC.Classes.Eq [Main.Optional] = Main.$fEqOptional
instance [safe] GHC.Base.Monoid [Main.First'] = Main.$fMonoidFirst'
instance [safe] GHC.Base.Monoid [Main.Optional]
  = Main.$fMonoidOptional
instance [safe] GHC.Base.Semigroup [Main.First']
  = Main.$fSemigroupFirst'
instance [safe] GHC.Base.Semigroup [Main.Optional]
  = Main.$fSemigroupOptional
instance [safe] GHC.Show.Show [Main.First'] = Main.$fShowFirst'
instance [safe] GHC.Show.Show [Main.Optional] = Main.$fShowOptional
"SPEC $carbitrary @ [Char]" forall ($dArbitrary :: Test.QuickCheck.Arbitrary.Arbitrary
                                                     [GHC.Types.Char])
  Main.$fArbitraryFirst'1 @ [GHC.Types.Char] $dArbitrary
  = Main.$fArbitraryFirst'_$s$carbitrary
"SPEC $cshow @ [Char]" forall ($dShow :: GHC.Show.Show
                                           [GHC.Types.Char])
  Main.$fShowFirst'_$cshow @ [GHC.Types.Char] $dShow
  = Main.$fShowFirst'_$s$cshow
"SPEC $cshowList @ [Char]" forall ($dShow :: GHC.Show.Show
                                               [GHC.Types.Char])
  Main.$fShowFirst'_$cshowList @ [GHC.Types.Char] $dShow
  = Main.$fShowFirst'_$s$cshowList
"SPEC $cshowsPrec @ [Char]" forall ($dShow :: GHC.Show.Show
                                                [GHC.Types.Char])
  Main.$fShowFirst'_$cshowsPrec @ [GHC.Types.Char] $dShow
  = Main.$fShowFirst'_$s$cshowsPrec
"SPEC $fShowFirst' @ [Char]" forall ($dShow :: GHC.Show.Show
                                                 [GHC.Types.Char])
  Main.$fShowFirst' @ [GHC.Types.Char] $dShow
  = Main.$fShowFirst'_$s$fShowFirst'
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

